/* tslint:disable */
/* eslint-disable */
/**
 * dAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'address': string;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'canTrade': boolean;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'updateTime': number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'feeTier': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'totalPositionQtyReduced': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'totalPositionQtyReducible': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'totalPositionMargin': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'totalUnrealizedProfit': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'totalExpectedPnl': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'walletBalance': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'freeCollateral': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'accountValue': string;
    /**
     * 
     * @type {Array<AccountDataByMarket>}
     * @memberof Account
     */
    'accountDataByMarket': Array<AccountDataByMarket>;
}
/**
 * 
 * @export
 * @interface AccountDataByMarket
 */
export interface AccountDataByMarket {
    /**
     * 
     * @type {string}
     * @memberof AccountDataByMarket
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof AccountDataByMarket
     */
    'positionQtyReduced': string;
    /**
     * 
     * @type {string}
     * @memberof AccountDataByMarket
     */
    'positionQtyReducible': string;
    /**
     * 
     * @type {string}
     * @memberof AccountDataByMarket
     */
    'positionMargin': string;
    /**
     * 
     * @type {string}
     * @memberof AccountDataByMarket
     */
    'unrealizedProfit': string;
    /**
     * 
     * @type {string}
     * @memberof AccountDataByMarket
     */
    'expectedPnl': string;
    /**
     * 
     * @type {string}
     * @memberof AccountDataByMarket
     */
    'selectedLeverage'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AccountValueTimeInterval = {
    _1h: '1h',
    _1d: '1d',
    _1w: '1w',
    _1M: '1M',
    _1y: '1y'
} as const;

export type AccountValueTimeInterval = typeof AccountValueTimeInterval[keyof typeof AccountValueTimeInterval];


/**
 * 
 * @export
 * @interface AccountWhitelistedAuthResponse
 */
export interface AccountWhitelistedAuthResponse {
    /**
     * 
     * @type {boolean}
     * @memberof AccountWhitelistedAuthResponse
     */
    'isWhitelisted': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccountWhitelistedAuthResponse
     */
    'cached': boolean;
}
/**
 * 
 * @export
 * @interface AdjustLeverage200Response
 */
export interface AdjustLeverage200Response {
    /**
     * 
     * @type {string}
     * @memberof AdjustLeverage200Response
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof AdjustLeverage200Response
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof AdjustLeverage200Response
     */
    'leverage': string;
    /**
     * 
     * @type {string}
     * @memberof AdjustLeverage200Response
     */
    'maxNotionalValue': string;
    /**
     * 
     * @type {MarginType}
     * @memberof AdjustLeverage200Response
     */
    'marginType': MarginType;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof AdjustLeverage200Response
     */
    'error': ErrorResponseError;
}


/**
 * 
 * @export
 * @interface AdjustLeverageRequest
 */
export interface AdjustLeverageRequest {
    /**
     * 
     * @type {string}
     * @memberof AdjustLeverageRequest
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof AdjustLeverageRequest
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof AdjustLeverageRequest
     */
    'leverage': string;
    /**
     * 
     * @type {MarginType}
     * @memberof AdjustLeverageRequest
     */
    'marginType': MarginType;
    /**
     * 
     * @type {string}
     * @memberof AdjustLeverageRequest
     */
    'callerAddress'?: string;
}


/**
 * 
 * @export
 * @interface AdjustLeverageResponse
 */
export interface AdjustLeverageResponse {
    /**
     * 
     * @type {string}
     * @memberof AdjustLeverageResponse
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof AdjustLeverageResponse
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof AdjustLeverageResponse
     */
    'leverage': string;
    /**
     * 
     * @type {string}
     * @memberof AdjustLeverageResponse
     */
    'maxNotionalValue': string;
    /**
     * 
     * @type {MarginType}
     * @memberof AdjustLeverageResponse
     */
    'marginType': MarginType;
}


/**
 * 
 * @export
 * @interface ApiResponseDeleteOrdersResponse
 */
export interface ApiResponseDeleteOrdersResponse {
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDeleteOrdersResponse
     */
    'message'?: string;
    /**
     * 
     * @type {DeleteOrdersResponse}
     * @memberof ApiResponseDeleteOrdersResponse
     */
    'data'?: DeleteOrdersResponse;
}
/**
 * 
 * @export
 * @interface AppInfoResponse
 */
export interface AppInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof AppInfoResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AppInfoResponse
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface Auth200Response
 */
export interface Auth200Response {
    /**
     * 
     * @type {string}
     * @memberof Auth200Response
     */
    'token': string;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof Auth200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface AuthTokenResponse
 */
export interface AuthTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenResponse
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface Config
 */
export interface Config {
    /**
     * 
     * @type {PartialAuxiliaryContractAddresses}
     * @memberof Config
     */
    'auxiliaryContractsAddresses': PartialAuxiliaryContractAddresses;
}
/**
 * 
 * @export
 * @interface CountryAuthResponse
 */
export interface CountryAuthResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CountryAuthResponse
     */
    'isBlockedCountry': boolean;
}
/**
 * 
 * @export
 * @interface CountryAuthorization200Response
 */
export interface CountryAuthorization200Response {
    /**
     * 
     * @type {boolean}
     * @memberof CountryAuthorization200Response
     */
    'isBlockedCountry': boolean;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof CountryAuthorization200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface CreateFeedback200Response
 */
export interface CreateFeedback200Response {
    /**
     * 
     * @type {string}
     * @memberof CreateFeedback200Response
     */
    'message': string;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof CreateFeedback200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface CreateOrder201Response
 */
export interface CreateOrder201Response {
    /**
     * 
     * @type {number}
     * @memberof CreateOrder201Response
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CreateOrder201Response
     */
    'clientId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreateOrder201Response
     */
    'requestTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateOrder201Response
     */
    'cancelReason'?: string;
    /**
     * 
     * @type {OrderStatus}
     * @memberof CreateOrder201Response
     */
    'orderStatus': OrderStatus;
    /**
     * 
     * @type {string}
     * @memberof CreateOrder201Response
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrder201Response
     */
    'symbol': string;
    /**
     * 
     * @type {OrderType}
     * @memberof CreateOrder201Response
     */
    'orderType': OrderType;
    /**
     * 
     * @type {TimeInForce}
     * @memberof CreateOrder201Response
     */
    'timeInForce': TimeInForce;
    /**
     * 
     * @type {string}
     * @memberof CreateOrder201Response
     */
    'userAddress': string;
    /**
     * 
     * @type {Side}
     * @memberof CreateOrder201Response
     */
    'side': Side;
    /**
     * 
     * @type {string}
     * @memberof CreateOrder201Response
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrder201Response
     */
    'triggerPrice': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrder201Response
     */
    'quantity': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrder201Response
     */
    'leverage': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrder201Response
     */
    'reduceOnly': boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateOrder201Response
     */
    'expiration': number;
    /**
     * 
     * @type {string}
     * @memberof CreateOrder201Response
     */
    'salt': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrder201Response
     */
    'filledQty': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrder201Response
     */
    'openQty': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrder201Response
     */
    'avgFillPrice': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrder201Response
     */
    'makerFee': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrder201Response
     */
    'takerFee': string;
    /**
     * 
     * @type {number}
     * @memberof CreateOrder201Response
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof CreateOrder201Response
     */
    'updatedAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrder201Response
     */
    'postOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrder201Response
     */
    'cancelOnRevert': boolean;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof CreateOrder201Response
     */
    'error': ErrorResponseError;
}


/**
 * 
 * @export
 * @interface DeleteOrder200Response
 */
export interface DeleteOrder200Response {
    /**
     * 
     * @type {number}
     * @memberof DeleteOrder200Response
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'clientId': string;
    /**
     * 
     * @type {number}
     * @memberof DeleteOrder200Response
     */
    'requestTime': number;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'cancelReason': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'orderStatus': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'orderType': string;
    /**
     * 
     * @type {number}
     * @memberof DeleteOrder200Response
     */
    'orderTypeID': number;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'timeInForce': string;
    /**
     * 
     * @type {number}
     * @memberof DeleteOrder200Response
     */
    'timeInForceTypeID': number;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'userAddress': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'side': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'triggerPrice': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'quantity': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'leverage': string;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteOrder200Response
     */
    'reduceOnly': boolean;
    /**
     * 
     * @type {number}
     * @memberof DeleteOrder200Response
     */
    'expiration': number;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'salt': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'orderSignature': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'filledQty': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'openQty': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'avgFillPrice': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'makerFee': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'takerFee': string;
    /**
     * 
     * @type {number}
     * @memberof DeleteOrder200Response
     */
    'updatedAt': number;
    /**
     * 
     * @type {number}
     * @memberof DeleteOrder200Response
     */
    'createdAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteOrder200Response
     */
    'postOnly': boolean;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'fee': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrder200Response
     */
    'margin': string;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteOrder200Response
     */
    'cancelOnRevert': boolean;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof DeleteOrder200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface DeleteOrderDTO
 */
export interface DeleteOrderDTO {
    /**
     * 
     * @type {string}
     * @memberof DeleteOrderDTO
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrderDTO
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface DeleteOrders200Response
 */
export interface DeleteOrders200Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteOrders200Response
     */
    'message'?: string;
    /**
     * 
     * @type {DeleteOrdersResponse}
     * @memberof DeleteOrders200Response
     */
    'data'?: DeleteOrdersResponse;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof DeleteOrders200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface DeleteOrdersParam
 */
export interface DeleteOrdersParam {
    /**
     * 
     * @type {string}
     * @memberof DeleteOrdersParam
     */
    'symbol': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteOrdersParam
     */
    'orderHashes': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrdersParam
     */
    'cancelSignature': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteOrdersParam
     */
    'parentAddress'?: string;
}
/**
 * 
 * @export
 * @interface DeleteOrdersResponse
 */
export interface DeleteOrdersResponse {
    /**
     * 
     * @type {Array<DeleteOrderDTO>}
     * @memberof DeleteOrdersResponse
     */
    'acceptedForCancelling': Array<DeleteOrderDTO>;
    /**
     * 
     * @type {Array<DeleteOrderDTO>}
     * @memberof DeleteOrdersResponse
     */
    'failedCancelling': Array<DeleteOrderDTO>;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof ErrorResponse
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface ErrorResponseError
 */
export interface ErrorResponseError {
    /**
     * 
     * @type {ErrorResponseErrorData}
     * @memberof ErrorResponseError
     */
    'data'?: ErrorResponseErrorData;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseError
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof ErrorResponseError
     */
    'code': number;
}
/**
 * 
 * @export
 * @interface ErrorResponseErrorData
 */
export interface ErrorResponseErrorData {
}
/**
 * 
 * @export
 * @interface ExchangeInfo
 */
export interface ExchangeInfo {
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'symbol': string;
    /**
     * 
     * @type {MarketStatus}
     * @memberof ExchangeInfo
     */
    'status': MarketStatus;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'baseAssetSymbol': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'baseAssetName': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'quoteAssetSymbol': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'quoteAssetName': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'maintenanceMarginReq': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'initialMarginReq': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'stepSize': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'tickSize': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'minOrderSize': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'maxLimitOrderSize': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'maxMarketOrderSize': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'minOrderPrice': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'maxOrderPrice': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'defaultMakerFee': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'defaultTakerFee': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'insurancePoolPercentage': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'mtbLong': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'mtbShort': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'defaultLeverage': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExchangeInfo
     */
    'maxAllowedOIOpen': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ExchangeInfo
     */
    'networkGasFee': string;
}


/**
 * 
 * @export
 * @interface Faucet200Response
 */
export interface Faucet200Response {
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof Faucet200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface FaucetRequest
 */
export interface FaucetRequest {
    /**
     * 
     * @type {string}
     * @memberof FaucetRequest
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof FaucetRequest
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof FaucetRequest
     */
    'depositToMarginBank': boolean;
}
/**
 * 
 * @export
 * @interface FeedbackSubmissionRequest
 */
export interface FeedbackSubmissionRequest {
    /**
     * 
     * @type {string}
     * @memberof FeedbackSubmissionRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof FeedbackSubmissionRequest
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof FeedbackSubmissionRequest
     */
    'client'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeedbackSubmissionRequest
     */
    'userAddress': string;
}
/**
 * 
 * @export
 * @interface FeedbackSubmissionResponse
 */
export interface FeedbackSubmissionResponse {
    /**
     * 
     * @type {string}
     * @memberof FeedbackSubmissionResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface FundingDTO
 */
export interface FundingDTO {
    /**
     * 
     * @type {string}
     * @memberof FundingDTO
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof FundingDTO
     */
    'fundingRate': string;
    /**
     * 
     * @type {number}
     * @memberof FundingDTO
     */
    'nextTime': number;
    /**
     * 
     * @type {number}
     * @memberof FundingDTO
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof FundingDTO
     */
    'avgFundingRate': string;
}
/**
 * 
 * @export
 * @interface Get200Response
 */
export interface Get200Response {
    /**
     * 
     * @type {string}
     * @memberof Get200Response
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Get200Response
     */
    'version': string;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof Get200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface GetAccount200Response
 */
export interface GetAccount200Response {
    /**
     * 
     * @type {string}
     * @memberof GetAccount200Response
     */
    'address': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetAccount200Response
     */
    'canTrade': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetAccount200Response
     */
    'updateTime': number;
    /**
     * 
     * @type {string}
     * @memberof GetAccount200Response
     */
    'feeTier': string;
    /**
     * 
     * @type {string}
     * @memberof GetAccount200Response
     */
    'totalPositionQtyReduced': string;
    /**
     * 
     * @type {string}
     * @memberof GetAccount200Response
     */
    'totalPositionQtyReducible': string;
    /**
     * 
     * @type {string}
     * @memberof GetAccount200Response
     */
    'totalPositionMargin': string;
    /**
     * 
     * @type {string}
     * @memberof GetAccount200Response
     */
    'totalUnrealizedProfit': string;
    /**
     * 
     * @type {string}
     * @memberof GetAccount200Response
     */
    'totalExpectedPnl': string;
    /**
     * 
     * @type {string}
     * @memberof GetAccount200Response
     */
    'walletBalance': string;
    /**
     * 
     * @type {string}
     * @memberof GetAccount200Response
     */
    'freeCollateral': string;
    /**
     * 
     * @type {string}
     * @memberof GetAccount200Response
     */
    'accountValue': string;
    /**
     * 
     * @type {Array<AccountDataByMarket>}
     * @memberof GetAccount200Response
     */
    'accountDataByMarket': Array<AccountDataByMarket>;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetAccount200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface GetAuxiliaryAddresses200Response
 */
export interface GetAuxiliaryAddresses200Response {
    /**
     * 
     * @type {PartialAuxiliaryContractAddresses}
     * @memberof GetAuxiliaryAddresses200Response
     */
    'auxiliaryContractsAddresses': PartialAuxiliaryContractAddresses;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetAuxiliaryAddresses200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface GetContractAddresses200Response
 */
export interface GetContractAddresses200Response {
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetContractAddresses200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface GetExchangeInfo200Response
 */
export interface GetExchangeInfo200Response {
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'symbol': string;
    /**
     * 
     * @type {MarketStatus}
     * @memberof GetExchangeInfo200Response
     */
    'status': MarketStatus;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'baseAssetSymbol': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'baseAssetName': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'quoteAssetSymbol': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'quoteAssetName': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'maintenanceMarginReq': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'initialMarginReq': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'stepSize': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'tickSize': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'minOrderSize': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'maxLimitOrderSize': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'maxMarketOrderSize': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'minOrderPrice': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'maxOrderPrice': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'defaultMakerFee': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'defaultTakerFee': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'insurancePoolPercentage': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'mtbLong': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'mtbShort': string;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'defaultLeverage': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetExchangeInfo200Response
     */
    'maxAllowedOIOpen': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetExchangeInfo200Response
     */
    'networkGasFee': string;
}


/**
 * 
 * @export
 * @interface GetFundingRate200Response
 */
export interface GetFundingRate200Response {
    /**
     * 
     * @type {string}
     * @memberof GetFundingRate200Response
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof GetFundingRate200Response
     */
    'fundingRate': string;
    /**
     * 
     * @type {number}
     * @memberof GetFundingRate200Response
     */
    'nextTime': number;
    /**
     * 
     * @type {number}
     * @memberof GetFundingRate200Response
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof GetFundingRate200Response
     */
    'avgFundingRate': string;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetFundingRate200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface GetMarketData200Response
 */
export interface GetMarketData200Response {
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    'lastQty': string;
    /**
     * 
     * @type {number}
     * @memberof GetMarketData200Response
     */
    'lastTime': number;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    'lastPrice': string;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    '_24hrHighPrice': string;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    '_24hrLowPrice': string;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    '_24hrVolume': string;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    '_24hrQuoteVolume': string;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    '_24hrClosePrice': string;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    '_24hrOpenPrice': string;
    /**
     * 
     * @type {number}
     * @memberof GetMarketData200Response
     */
    '_24hrCloseTime': number;
    /**
     * 
     * @type {number}
     * @memberof GetMarketData200Response
     */
    '_24hrOpenTime': number;
    /**
     * 
     * @type {number}
     * @memberof GetMarketData200Response
     */
    '_24hrFirstId': number;
    /**
     * 
     * @type {number}
     * @memberof GetMarketData200Response
     */
    '_24hrLastId': number;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    '_24hrCount': string;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    'lastFundingRate': string;
    /**
     * 
     * @type {number}
     * @memberof GetMarketData200Response
     */
    'nextFundingTime': number;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    'avgFundingRate': string;
    /**
     * 
     * @type {number}
     * @memberof GetMarketData200Response
     */
    'time': number;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    '_24hrPriceChange': string;
    /**
     * 
     * @type {number}
     * @memberof GetMarketData200Response
     */
    'midMarketPriceDirection': number;
    /**
     * 
     * @type {number}
     * @memberof GetMarketData200Response
     */
    'marketPriceDirection': number;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    '_24hrPriceChangePercent': string;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    'oraclePrice': string;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    'indexPrice': string;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    'marketPrice': string;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    'midMarketPrice': string;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    'bestBidPrice': string;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    'bestBidQty': string;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    'bestAskPrice': string;
    /**
     * 
     * @type {string}
     * @memberof GetMarketData200Response
     */
    'bestAskQty': string;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetMarketData200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface GetMarketSymbols200Response
 */
export interface GetMarketSymbols200Response {
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetMarketSymbols200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface GetMasterInfo200Response
 */
export interface GetMasterInfo200Response {
    /**
     * 
     * @type {Array<SymbolMasterInfo>}
     * @memberof GetMasterInfo200Response
     */
    'data': Array<SymbolMasterInfo>;
    /**
     * 
     * @type {string}
     * @memberof GetMasterInfo200Response
     */
    '_24hrVolume': string;
    /**
     * 
     * @type {string}
     * @memberof GetMasterInfo200Response
     */
    '_24hrTrades': string;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetMasterInfo200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface GetMeta200Response
 */
export interface GetMeta200Response {
    /**
     * 
     * @type {string}
     * @memberof GetMeta200Response
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof GetMeta200Response
     */
    'domainHash': string;
    /**
     * 
     * @type {string}
     * @memberof GetMeta200Response
     */
    'onboardingWebsiteUrl': string;
    /**
     * 
     * @type {string}
     * @memberof GetMeta200Response
     */
    'rpcURI': string;
    /**
     * 
     * @type {string}
     * @memberof GetMeta200Response
     */
    'networkID': string;
    /**
     * 
     * @type {string}
     * @memberof GetMeta200Response
     */
    'orderAddress': string;
    /**
     * 
     * @type {string}
     * @memberof GetMeta200Response
     */
    'liquidationAddress': string;
    /**
     * 
     * @type {string}
     * @memberof GetMeta200Response
     */
    'perpetualAddress': string;
}
/**
 * 
 * @export
 * @interface GetOrder200Response
 */
export interface GetOrder200Response {
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetOrder200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface GetOrder200Response1
 */
export interface GetOrder200Response1 {
    /**
     * 
     * @type {boolean}
     * @memberof GetOrder200Response1
     */
    'isMoreDataAvailable': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetOrder200Response1
     */
    'nextCursor': number;
    /**
     * 
     * @type {Array<OrderDTO>}
     * @memberof GetOrder200Response1
     */
    'data': Array<OrderDTO>;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetOrder200Response1
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface GetRecentTrade200Response
 */
export interface GetRecentTrade200Response {
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetRecentTrade200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface GetRecentTrade200Response1
 */
export interface GetRecentTrade200Response1 {
    /**
     * 
     * @type {boolean}
     * @memberof GetRecentTrade200Response1
     */
    'isMoreDataAvailable': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetRecentTrade200Response1
     */
    'nextCursor': number;
    /**
     * 
     * @type {Array<RecentTradesDTO>}
     * @memberof GetRecentTrade200Response1
     */
    'data': Array<RecentTradesDTO>;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetRecentTrade200Response1
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface GetUserFundingHistory200Response
 */
export interface GetUserFundingHistory200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetUserFundingHistory200Response
     */
    'isMoreDataAvailable': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetUserFundingHistory200Response
     */
    'nextCursor': number;
    /**
     * 
     * @type {Array<UserFundingDTO>}
     * @memberof GetUserFundingHistory200Response
     */
    'data': Array<UserFundingDTO>;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetUserFundingHistory200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface GetUserPosition200Response
 */
export interface GetUserPosition200Response {
    /**
     * 
     * @type {string}
     * @memberof GetUserPosition200Response
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPosition200Response
     */
    'avgEntryPrice': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPosition200Response
     */
    'marginType': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPosition200Response
     */
    'userAddress': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPosition200Response
     */
    'margin': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPosition200Response
     */
    'liquidationPrice': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPosition200Response
     */
    'midMarketPrice': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPosition200Response
     */
    'positionValue': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPosition200Response
     */
    'quantity': string;
    /**
     * 
     * @type {Side}
     * @memberof GetUserPosition200Response
     */
    'side': Side;
    /**
     * 
     * @type {string}
     * @memberof GetUserPosition200Response
     */
    'leverage': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPosition200Response
     */
    'unrealizedProfit': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPosition200Response
     */
    'unrealizedProfitPercent': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPosition200Response
     */
    'positionSelectedLeverage': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPosition200Response
     */
    'latestTxHash': string;
    /**
     * 
     * @type {number}
     * @memberof GetUserPosition200Response
     */
    'latestBlockNumber': number;
    /**
     * 
     * @type {string}
     * @memberof GetUserPosition200Response
     */
    'oraclePrice': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPosition200Response
     */
    'indexPrice': string;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetUserPosition200Response
     */
    'error': ErrorResponseError;
}


/**
 * 
 * @export
 * @interface GetUserTrade200Response
 */
export interface GetUserTrade200Response {
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetUserTrade200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface GetUserTradeHistory200Response
 */
export interface GetUserTradeHistory200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetUserTradeHistory200Response
     */
    'isMoreDataAvailable': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetUserTradeHistory200Response
     */
    'nextCursor': number;
    /**
     * 
     * @type {Array<IUserTradeView>}
     * @memberof GetUserTradeHistory200Response
     */
    'data': Array<IUserTradeView>;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetUserTradeHistory200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface GetUserTransactionHistory200Response
 */
export interface GetUserTransactionHistory200Response {
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetUserTransactionHistory200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface GetUserTransactionHistory200Response1
 */
export interface GetUserTransactionHistory200Response1 {
    /**
     * 
     * @type {boolean}
     * @memberof GetUserTransactionHistory200Response1
     */
    'isMoreDataAvailable': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetUserTransactionHistory200Response1
     */
    'nextCursor': number;
    /**
     * 
     * @type {Array<UserTransactionHistoryDTO>}
     * @memberof GetUserTransactionHistory200Response1
     */
    'data': Array<UserTransactionHistoryDTO>;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetUserTransactionHistory200Response1
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface GetUserTransfer200Response
 */
export interface GetUserTransfer200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetUserTransfer200Response
     */
    'isMoreDataAvailable': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetUserTransfer200Response
     */
    'nextCursor': number;
    /**
     * 
     * @type {Array<IUserTransferHistory>}
     * @memberof GetUserTransfer200Response
     */
    'data': Array<IUserTransferHistory>;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof GetUserTransfer200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface IRefereesDetails
 */
export interface IRefereesDetails {
    /**
     * 
     * @type {string}
     * @memberof IRefereesDetails
     */
    'refereeWalletAdd': string;
    /**
     * 
     * @type {string}
     * @memberof IRefereesDetails
     */
    'totalDeposit': string;
    /**
     * 
     * @type {string}
     * @memberof IRefereesDetails
     */
    'tradingVolume': string;
    /**
     * 
     * @type {MileStone}
     * @memberof IRefereesDetails
     */
    'milestoneAchieved'?: MileStone;
    /**
     * 
     * @type {string}
     * @memberof IRefereesDetails
     */
    'tradingPoints': string;
}


/**
 * 
 * @export
 * @interface ITradeAllianceMemberMonthlyOverview
 */
export interface ITradeAllianceMemberMonthlyOverview {
    /**
     * 
     * @type {string}
     * @memberof ITradeAllianceMemberMonthlyOverview
     */
    'userAddress': string;
    /**
     * 
     * @type {string}
     * @memberof ITradeAllianceMemberMonthlyOverview
     */
    'totalTakerVolume': string;
    /**
     * 
     * @type {string}
     * @memberof ITradeAllianceMemberMonthlyOverview
     */
    'totalMakerVolume': string;
    /**
     * 
     * @type {string}
     * @memberof ITradeAllianceMemberMonthlyOverview
     */
    'totalTakerFeesPaid': string;
    /**
     * 
     * @type {string}
     * @memberof ITradeAllianceMemberMonthlyOverview
     */
    'totalMakerFeesPaid': string;
    /**
     * 
     * @type {string}
     * @memberof ITradeAllianceMemberMonthlyOverview
     */
    'totalDeposit': string;
    /**
     * 
     * @type {string}
     * @memberof ITradeAllianceMemberMonthlyOverview
     */
    'totalWithdraw': string;
    /**
     * 
     * @type {MileStone}
     * @memberof ITradeAllianceMemberMonthlyOverview
     */
    'milestoneAchieved': MileStone;
    /**
     * 
     * @type {string}
     * @memberof ITradeAllianceMemberMonthlyOverview
     */
    'rewardedTradingPoints': string;
    /**
     * 
     * @type {number}
     * @memberof ITradeAllianceMemberMonthlyOverview
     */
    'monthTimestamp': number;
}


/**
 * 
 * @export
 * @interface IUserTradeOverview
 */
export interface IUserTradeOverview {
    /**
     * 
     * @type {string}
     * @memberof IUserTradeOverview
     */
    'totalDeposit': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTradeOverview
     */
    'totalTradingVolume': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTradeOverview
     */
    'totalFees': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTradeOverview
     */
    'totalWithdraw': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTradeOverview
     */
    'totalProfit': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTradeOverview
     */
    'totalLoss': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTradeOverview
     */
    'totalPnl': string;
}
/**
 * 
 * @export
 * @interface IUserTradeView
 */
export interface IUserTradeView {
    /**
     * 
     * @type {number}
     * @memberof IUserTradeView
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof IUserTradeView
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTradeView
     */
    'commission': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTradeView
     */
    'orderHash': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTradeView
     */
    'commissionAsset': string;
    /**
     * 
     * @type {boolean}
     * @memberof IUserTradeView
     */
    'maker': boolean;
    /**
     * 
     * @type {string}
     * @memberof IUserTradeView
     */
    'side': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTradeView
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTradeView
     */
    'quantity': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTradeView
     */
    'quoteQty': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTradeView
     */
    'clientId': string;
    /**
     * 
     * @type {number}
     * @memberof IUserTradeView
     */
    'orderId': number;
    /**
     * 
     * @type {string}
     * @memberof IUserTradeView
     */
    'realizedPnl': string;
    /**
     * 
     * @type {TradeType}
     * @memberof IUserTradeView
     */
    'tradeType': TradeType;
    /**
     * 
     * @type {number}
     * @memberof IUserTradeView
     */
    'time': number;
    /**
     * 
     * @type {string}
     * @memberof IUserTradeView
     */
    'networkGasFee': string;
}


/**
 * 
 * @export
 * @interface IUserTransactionHistory
 */
export interface IUserTransactionHistory {
    /**
     * 
     * @type {number}
     * @memberof IUserTransactionHistory
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof IUserTransactionHistory
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTransactionHistory
     */
    'traderType': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTransactionHistory
     */
    'commission': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTransactionHistory
     */
    'commissionAsset': string;
    /**
     * 
     * @type {boolean}
     * @memberof IUserTransactionHistory
     */
    'maker': boolean;
    /**
     * 
     * @type {Side}
     * @memberof IUserTransactionHistory
     */
    'side': Side;
    /**
     * 
     * @type {string}
     * @memberof IUserTransactionHistory
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTransactionHistory
     */
    'quantity': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTransactionHistory
     */
    'quoteQty': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTransactionHistory
     */
    'notionalValue': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTransactionHistory
     */
    'realizedPnl': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTransactionHistory
     */
    'orderHash': string;
    /**
     * 
     * @type {TradeType}
     * @memberof IUserTransactionHistory
     */
    'tradeType': TradeType;
    /**
     * 
     * @type {number}
     * @memberof IUserTransactionHistory
     */
    'time': number;
}


/**
 * 
 * @export
 * @interface IUserTransferHistory
 */
export interface IUserTransferHistory {
    /**
     * 
     * @type {number}
     * @memberof IUserTransferHistory
     */
    'id': number;
    /**
     * 
     * @type {TransferStatuses}
     * @memberof IUserTransferHistory
     */
    'status': TransferStatuses;
    /**
     * 
     * @type {TransferActions}
     * @memberof IUserTransferHistory
     */
    'action': TransferActions;
    /**
     * 
     * @type {string}
     * @memberof IUserTransferHistory
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof IUserTransferHistory
     */
    'userAddress': string;
    /**
     * 
     * @type {number}
     * @memberof IUserTransferHistory
     */
    'blockNumber': number;
    /**
     * 
     * @type {string}
     * @memberof IUserTransferHistory
     */
    'latestTxHash': string;
    /**
     * 
     * @type {number}
     * @memberof IUserTransferHistory
     */
    'time': number;
    /**
     * 
     * @type {number}
     * @memberof IUserTransferHistory
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof IUserTransferHistory
     */
    'updatedAt': number;
}


/**
 * 
 * @export
 * @interface IsWhitelistedAccount200Response
 */
export interface IsWhitelistedAccount200Response {
    /**
     * 
     * @type {boolean}
     * @memberof IsWhitelistedAccount200Response
     */
    'isWhitelisted': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IsWhitelistedAccount200Response
     */
    'cached': boolean;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof IsWhitelistedAccount200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface ListingWithCursorIRefereesDetails
 */
export interface ListingWithCursorIRefereesDetails {
    /**
     * 
     * @type {boolean}
     * @memberof ListingWithCursorIRefereesDetails
     */
    'isMoreDataAvailable': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListingWithCursorIRefereesDetails
     */
    'nextCursor': number;
    /**
     * 
     * @type {Array<IRefereesDetails>}
     * @memberof ListingWithCursorIRefereesDetails
     */
    'data': Array<IRefereesDetails>;
}
/**
 * 
 * @export
 * @interface ListingWithCursorITradeAllianceMemberMonthlyOverview
 */
export interface ListingWithCursorITradeAllianceMemberMonthlyOverview {
    /**
     * 
     * @type {boolean}
     * @memberof ListingWithCursorITradeAllianceMemberMonthlyOverview
     */
    'isMoreDataAvailable': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListingWithCursorITradeAllianceMemberMonthlyOverview
     */
    'nextCursor': number;
    /**
     * 
     * @type {Array<ITradeAllianceMemberMonthlyOverview>}
     * @memberof ListingWithCursorITradeAllianceMemberMonthlyOverview
     */
    'data': Array<ITradeAllianceMemberMonthlyOverview>;
}
/**
 * 
 * @export
 * @interface ListingWithCursorIUserTradeView
 */
export interface ListingWithCursorIUserTradeView {
    /**
     * 
     * @type {boolean}
     * @memberof ListingWithCursorIUserTradeView
     */
    'isMoreDataAvailable': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListingWithCursorIUserTradeView
     */
    'nextCursor': number;
    /**
     * 
     * @type {Array<IUserTradeView>}
     * @memberof ListingWithCursorIUserTradeView
     */
    'data': Array<IUserTradeView>;
}
/**
 * 
 * @export
 * @interface ListingWithCursorIUserTransferHistory
 */
export interface ListingWithCursorIUserTransferHistory {
    /**
     * 
     * @type {boolean}
     * @memberof ListingWithCursorIUserTransferHistory
     */
    'isMoreDataAvailable': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListingWithCursorIUserTransferHistory
     */
    'nextCursor': number;
    /**
     * 
     * @type {Array<IUserTransferHistory>}
     * @memberof ListingWithCursorIUserTransferHistory
     */
    'data': Array<IUserTransferHistory>;
}
/**
 * 
 * @export
 * @interface ListingWithCursorOrderDTO
 */
export interface ListingWithCursorOrderDTO {
    /**
     * 
     * @type {boolean}
     * @memberof ListingWithCursorOrderDTO
     */
    'isMoreDataAvailable': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListingWithCursorOrderDTO
     */
    'nextCursor': number;
    /**
     * 
     * @type {Array<OrderDTO>}
     * @memberof ListingWithCursorOrderDTO
     */
    'data': Array<OrderDTO>;
}
/**
 * 
 * @export
 * @interface ListingWithCursorRecentTradesDTO
 */
export interface ListingWithCursorRecentTradesDTO {
    /**
     * 
     * @type {boolean}
     * @memberof ListingWithCursorRecentTradesDTO
     */
    'isMoreDataAvailable': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListingWithCursorRecentTradesDTO
     */
    'nextCursor': number;
    /**
     * 
     * @type {Array<RecentTradesDTO>}
     * @memberof ListingWithCursorRecentTradesDTO
     */
    'data': Array<RecentTradesDTO>;
}
/**
 * 
 * @export
 * @interface ListingWithCursorUserFundingDTO
 */
export interface ListingWithCursorUserFundingDTO {
    /**
     * 
     * @type {boolean}
     * @memberof ListingWithCursorUserFundingDTO
     */
    'isMoreDataAvailable': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListingWithCursorUserFundingDTO
     */
    'nextCursor': number;
    /**
     * 
     * @type {Array<UserFundingDTO>}
     * @memberof ListingWithCursorUserFundingDTO
     */
    'data': Array<UserFundingDTO>;
}
/**
 * 
 * @export
 * @interface ListingWithCursorUserTransactionHistoryDTO
 */
export interface ListingWithCursorUserTransactionHistoryDTO {
    /**
     * 
     * @type {boolean}
     * @memberof ListingWithCursorUserTransactionHistoryDTO
     */
    'isMoreDataAvailable': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListingWithCursorUserTransactionHistoryDTO
     */
    'nextCursor': number;
    /**
     * 
     * @type {Array<UserTransactionHistoryDTO>}
     * @memberof ListingWithCursorUserTransactionHistoryDTO
     */
    'data': Array<UserTransactionHistoryDTO>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MOBILECLIENT = {
    Android: 'android',
    Ios: 'ios'
} as const;

export type MOBILECLIENT = typeof MOBILECLIENT[keyof typeof MOBILECLIENT];


/**
 * 
 * @export
 * @enum {string}
 */

export const MarginType = {
    Isolated: 'ISOLATED',
    Cross: 'CROSS'
} as const;

export type MarginType = typeof MarginType[keyof typeof MarginType];


/**
 * 
 * @export
 * @interface MarketData
 */
export interface MarketData {
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    'lastQty': string;
    /**
     * 
     * @type {number}
     * @memberof MarketData
     */
    'lastTime': number;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    'lastPrice': string;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    '_24hrHighPrice': string;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    '_24hrLowPrice': string;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    '_24hrVolume': string;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    '_24hrQuoteVolume': string;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    '_24hrClosePrice': string;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    '_24hrOpenPrice': string;
    /**
     * 
     * @type {number}
     * @memberof MarketData
     */
    '_24hrCloseTime': number;
    /**
     * 
     * @type {number}
     * @memberof MarketData
     */
    '_24hrOpenTime': number;
    /**
     * 
     * @type {number}
     * @memberof MarketData
     */
    '_24hrFirstId': number;
    /**
     * 
     * @type {number}
     * @memberof MarketData
     */
    '_24hrLastId': number;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    '_24hrCount': string;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    'lastFundingRate': string;
    /**
     * 
     * @type {number}
     * @memberof MarketData
     */
    'nextFundingTime': number;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    'avgFundingRate': string;
    /**
     * 
     * @type {number}
     * @memberof MarketData
     */
    'time': number;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    '_24hrPriceChange': string;
    /**
     * 
     * @type {number}
     * @memberof MarketData
     */
    'midMarketPriceDirection': number;
    /**
     * 
     * @type {number}
     * @memberof MarketData
     */
    'marketPriceDirection': number;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    '_24hrPriceChangePercent': string;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    'oraclePrice': string;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    'indexPrice': string;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    'marketPrice': string;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    'midMarketPrice': string;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    'bestBidPrice': string;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    'bestBidQty': string;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    'bestAskPrice': string;
    /**
     * 
     * @type {string}
     * @memberof MarketData
     */
    'bestAskQty': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MarketStatus = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    TradesInactive: 'TRADES_INACTIVE',
    Beta: 'BETA'
} as const;

export type MarketStatus = typeof MarketStatus[keyof typeof MarketStatus];


/**
 * 
 * @export
 * @interface MasterInfo
 */
export interface MasterInfo {
    /**
     * 
     * @type {Array<SymbolMasterInfo>}
     * @memberof MasterInfo
     */
    'data': Array<SymbolMasterInfo>;
    /**
     * 
     * @type {string}
     * @memberof MasterInfo
     */
    '_24hrVolume': string;
    /**
     * 
     * @type {string}
     * @memberof MasterInfo
     */
    '_24hrTrades': string;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * 
     * @type {string}
     * @memberof Meta
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof Meta
     */
    'domainHash': string;
    /**
     * 
     * @type {string}
     * @memberof Meta
     */
    'onboardingWebsiteUrl': string;
    /**
     * 
     * @type {string}
     * @memberof Meta
     */
    'rpcURI': string;
    /**
     * 
     * @type {string}
     * @memberof Meta
     */
    'networkID': string;
    /**
     * 
     * @type {string}
     * @memberof Meta
     */
    'orderAddress': string;
    /**
     * 
     * @type {string}
     * @memberof Meta
     */
    'liquidationAddress': string;
    /**
     * 
     * @type {string}
     * @memberof Meta
     */
    'perpetualAddress': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MileStone = {
    I: 'I',
    Ii: 'II',
    Iii: 'III',
    Iv: 'IV',
    VipSilver: 'VIP Silver',
    VipGold: 'VIP Gold',
    VipPlatinum: 'VIP Platinum'
} as const;

export type MileStone = typeof MileStone[keyof typeof MileStone];


/**
 * 
 * @export
 * @interface MinimumSupportVersion200Response
 */
export interface MinimumSupportVersion200Response {
    /**
     * 
     * @type {string}
     * @memberof MinimumSupportVersion200Response
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof MinimumSupportVersion200Response
     */
    'build': string;
    /**
     * 
     * @type {boolean}
     * @memberof MinimumSupportVersion200Response
     */
    'isUnderMaintenance': boolean;
    /**
     * 
     * @type {Message}
     * @memberof MinimumSupportVersion200Response
     */
    'message': Message;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof MinimumSupportVersion200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface OrderBodyAttributes
 */
export interface OrderBodyAttributes {
    /**
     * 
     * @type {string}
     * @memberof OrderBodyAttributes
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderBodyAttributes
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof OrderBodyAttributes
     */
    'userAddress': string;
    /**
     * 
     * @type {OrderType}
     * @memberof OrderBodyAttributes
     */
    'orderType': OrderType;
    /**
     * 
     * @type {string}
     * @memberof OrderBodyAttributes
     */
    'price': string;
    /**
     * 
     * @type {Side}
     * @memberof OrderBodyAttributes
     */
    'side': Side;
    /**
     * 
     * @type {boolean}
     * @memberof OrderBodyAttributes
     */
    'reduceOnly': boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderBodyAttributes
     */
    'quantity': string;
    /**
     * 
     * @type {string}
     * @memberof OrderBodyAttributes
     */
    'leverage': string;
    /**
     * 
     * @type {number}
     * @memberof OrderBodyAttributes
     */
    'salt': number;
    /**
     * 
     * @type {number}
     * @memberof OrderBodyAttributes
     */
    'expiration': number;
    /**
     * 
     * @type {TimeInForce}
     * @memberof OrderBodyAttributes
     */
    'timeInForce': TimeInForce;
    /**
     * 
     * @type {string}
     * @memberof OrderBodyAttributes
     */
    'orderSignature': string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderBodyAttributes
     */
    'postOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrderBodyAttributes
     */
    'cancelOnRevert'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderBodyAttributes
     */
    'signerAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderBodyAttributes
     */
    'triggerPrice'?: string;
}


/**
 * 
 * @export
 * @interface OrderDTO
 */
export interface OrderDTO {
    /**
     * 
     * @type {number}
     * @memberof OrderDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'clientId': string;
    /**
     * 
     * @type {number}
     * @memberof OrderDTO
     */
    'requestTime': number;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'cancelReason': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'orderStatus': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'orderType': string;
    /**
     * 
     * @type {number}
     * @memberof OrderDTO
     */
    'orderTypeID': number;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'timeInForce': string;
    /**
     * 
     * @type {number}
     * @memberof OrderDTO
     */
    'timeInForceTypeID': number;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'userAddress': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'side': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'triggerPrice': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'quantity': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'leverage': string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDTO
     */
    'reduceOnly': boolean;
    /**
     * 
     * @type {number}
     * @memberof OrderDTO
     */
    'expiration': number;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'salt': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'orderSignature': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'filledQty': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'openQty': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'avgFillPrice': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'makerFee': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'takerFee': string;
    /**
     * 
     * @type {number}
     * @memberof OrderDTO
     */
    'updatedAt': number;
    /**
     * 
     * @type {number}
     * @memberof OrderDTO
     */
    'createdAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDTO
     */
    'postOnly': boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'fee': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'margin': string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDTO
     */
    'cancelOnRevert': boolean;
}
/**
 * 
 * @export
 * @interface OrderResponse
 */
export interface OrderResponse {
    /**
     * 
     * @type {number}
     * @memberof OrderResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'clientId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OrderResponse
     */
    'requestTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'cancelReason'?: string;
    /**
     * 
     * @type {OrderStatus}
     * @memberof OrderResponse
     */
    'orderStatus': OrderStatus;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'symbol': string;
    /**
     * 
     * @type {OrderType}
     * @memberof OrderResponse
     */
    'orderType': OrderType;
    /**
     * 
     * @type {TimeInForce}
     * @memberof OrderResponse
     */
    'timeInForce': TimeInForce;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'userAddress': string;
    /**
     * 
     * @type {Side}
     * @memberof OrderResponse
     */
    'side': Side;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'triggerPrice': string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'quantity': string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'leverage': string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderResponse
     */
    'reduceOnly': boolean;
    /**
     * 
     * @type {number}
     * @memberof OrderResponse
     */
    'expiration': number;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'salt': string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'filledQty': string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'openQty': string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'avgFillPrice': string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'makerFee': string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'takerFee': string;
    /**
     * 
     * @type {number}
     * @memberof OrderResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof OrderResponse
     */
    'updatedAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderResponse
     */
    'postOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrderResponse
     */
    'cancelOnRevert': boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const OrderStatus = {
    Pending: 'PENDING',
    Open: 'OPEN',
    PartialFilled: 'PARTIAL_FILLED',
    Filled: 'FILLED',
    Cancelling: 'CANCELLING',
    Cancelled: 'CANCELLED',
    Rejected: 'REJECTED',
    Expired: 'EXPIRED',
    StandByPending: 'STAND_BY_PENDING',
    StandBy: 'STAND_BY'
} as const;

export type OrderStatus = typeof OrderStatus[keyof typeof OrderStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const OrderType = {
    Limit: 'LIMIT',
    Market: 'MARKET',
    StopLimit: 'STOP_LIMIT',
    StopMarket: 'STOP_MARKET'
} as const;

export type OrderType = typeof OrderType[keyof typeof OrderType];


/**
 * 
 * @export
 * @interface Orderbook
 */
export interface Orderbook {
    /**
     * 
     * @type {number}
     * @memberof Orderbook
     */
    'limit': number;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof Orderbook
     */
    'asks': Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof Orderbook
     */
    'bids': Array<Array<string>>;
    /**
     * 
     * @type {string}
     * @memberof Orderbook
     */
    'bestBidPrice': string;
    /**
     * 
     * @type {string}
     * @memberof Orderbook
     */
    'bestBidQty': string;
    /**
     * 
     * @type {string}
     * @memberof Orderbook
     */
    'bestAskPrice': string;
    /**
     * 
     * @type {string}
     * @memberof Orderbook
     */
    'bestAskQty': string;
    /**
     * 
     * @type {string}
     * @memberof Orderbook
     */
    'midPrice': string;
    /**
     * 
     * @type {number}
     * @memberof Orderbook
     */
    'lastUpdatedAt': number;
    /**
     * 
     * @type {number}
     * @memberof Orderbook
     */
    'orderbookUpdateId': number;
    /**
     * 
     * @type {number}
     * @memberof Orderbook
     */
    'responseSentAt': number;
    /**
     * 
     * @type {string}
     * @memberof Orderbook
     */
    'oraclePrice': string;
    /**
     * 
     * @type {number}
     * @memberof Orderbook
     */
    'oraclePriceLastUpdateAt': number;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialAuxiliaryContractAddresses
 */
export interface PartialAuxiliaryContractAddresses {
    /**
     * 
     * @type {string}
     * @memberof PartialAuxiliaryContractAddresses
     */
    'FFLY'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAuxiliaryContractAddresses
     */
    'Governance'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAuxiliaryContractAddresses
     */
    'MarketMakingPool'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAuxiliaryContractAddresses
     */
    'SafetyStakingPool'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAuxiliaryContractAddresses
     */
    'Timelock'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAuxiliaryContractAddresses
     */
    'TokenVesting'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAuxiliaryContractAddresses
     */
    'TradeInfo'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAuxiliaryContractAddresses
     */
    'TradeMining'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAuxiliaryContractAddresses
     */
    'MarginBank'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAuxiliaryContractAddresses
     */
    'USDC'?: string;
}
/**
 * 
 * @export
 * @interface PartnerRefereeDetailsDto
 */
export interface PartnerRefereeDetailsDto {
    /**
     * 
     * @type {string}
     * @memberof PartnerRefereeDetailsDto
     */
    'refereeTotalDeposit': string;
    /**
     * 
     * @type {string}
     * @memberof PartnerRefereeDetailsDto
     */
    'refereeTotalTradingVol': string;
    /**
     * 
     * @type {string}
     * @memberof PartnerRefereeDetailsDto
     */
    'refereeTotalFeesPaid': string;
    /**
     * 
     * @type {ListingWithCursorIRefereesDetails}
     * @memberof PartnerRefereeDetailsDto
     */
    'refereeList': ListingWithCursorIRefereesDetails;
}
/**
 * 
 * @export
 * @interface RecentTrades
 */
export interface RecentTrades {
    /**
     * 
     * @type {number}
     * @memberof RecentTrades
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof RecentTrades
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof RecentTrades
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof RecentTrades
     */
    'quantity': string;
    /**
     * 
     * @type {string}
     * @memberof RecentTrades
     */
    'quoteQty': string;
    /**
     * 
     * @type {number}
     * @memberof RecentTrades
     */
    'time': number;
    /**
     * 
     * @type {Side}
     * @memberof RecentTrades
     */
    'side': Side;
}


/**
 * 
 * @export
 * @interface RecentTradesDTO
 */
export interface RecentTradesDTO {
    /**
     * 
     * @type {number}
     * @memberof RecentTradesDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof RecentTradesDTO
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof RecentTradesDTO
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof RecentTradesDTO
     */
    'quantity': string;
    /**
     * 
     * @type {string}
     * @memberof RecentTradesDTO
     */
    'quoteQty': string;
    /**
     * 
     * @type {number}
     * @memberof RecentTradesDTO
     */
    'time': number;
    /**
     * 
     * @type {Side}
     * @memberof RecentTradesDTO
     */
    'side': Side;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const Side = {
    Buy: 'BUY',
    Sell: 'SELL'
} as const;

export type Side = typeof Side[keyof typeof Side];


/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * 
     * @type {boolean}
     * @memberof Status
     */
    'isAlive': boolean;
    /**
     * 
     * @type {number}
     * @memberof Status
     */
    'serverTime': number;
}
/**
 * 
 * @export
 * @interface SupportedVersion
 */
export interface SupportedVersion {
    /**
     * 
     * @type {string}
     * @memberof SupportedVersion
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof SupportedVersion
     */
    'build': string;
    /**
     * 
     * @type {boolean}
     * @memberof SupportedVersion
     */
    'isUnderMaintenance': boolean;
    /**
     * 
     * @type {Message}
     * @memberof SupportedVersion
     */
    'message': Message;
}
/**
 * 
 * @export
 * @interface SymbolMasterInfo
 */
export interface SymbolMasterInfo {
    /**
     * 
     * @type {MarketData}
     * @memberof SymbolMasterInfo
     */
    'marketData': MarketData;
    /**
     * 
     * @type {ExchangeInfo}
     * @memberof SymbolMasterInfo
     */
    'exchangeInfo': ExchangeInfo;
    /**
     * 
     * @type {Meta}
     * @memberof SymbolMasterInfo
     */
    'meta': Meta;
    /**
     * 
     * @type {string}
     * @memberof SymbolMasterInfo
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface TAReferralBodyAttributes
 */
export interface TAReferralBodyAttributes {
    /**
     * 
     * @type {string}
     * @memberof TAReferralBodyAttributes
     */
    'accountAddress': string;
    /**
     * 
     * @type {string}
     * @memberof TAReferralBodyAttributes
     */
    'emailAddress': string;
}
/**
 * 
 * @export
 * @interface TAReferralCodeResponse
 */
export interface TAReferralCodeResponse {
    /**
     * 
     * @type {boolean}
     * @memberof TAReferralCodeResponse
     */
    'isReferralGenerated': boolean;
    /**
     * 
     * @type {TAReferralCodeResponseReferralDetails}
     * @memberof TAReferralCodeResponse
     */
    'referralDetails'?: TAReferralCodeResponseReferralDetails;
}
/**
 * 
 * @export
 * @interface TAReferralCodeResponseReferralDetails
 */
export interface TAReferralCodeResponseReferralDetails {
    /**
     * 
     * @type {number}
     * @memberof TAReferralCodeResponseReferralDetails
     */
    'acceptedCount': number;
    /**
     * 
     * @type {number}
     * @memberof TAReferralCodeResponseReferralDetails
     */
    'appliedCount': number;
    /**
     * 
     * @type {string}
     * @memberof TAReferralCodeResponseReferralDetails
     */
    'referralCode': string;
    /**
     * 
     * @type {string}
     * @memberof TAReferralCodeResponseReferralDetails
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface Ticker
 */
export interface Ticker {
    /**
     * 
     * @type {string}
     * @memberof Ticker
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof Ticker
     */
    '_24hrPriceChange': string;
    /**
     * 
     * @type {string}
     * @memberof Ticker
     */
    '_24hrPriceChangePercent': string;
    /**
     * 
     * @type {number}
     * @memberof Ticker
     */
    'openTime': number;
    /**
     * 
     * @type {number}
     * @memberof Ticker
     */
    'closeTime': number;
    /**
     * 
     * @type {string}
     * @memberof Ticker
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof Ticker
     */
    'oraclePrice': string;
    /**
     * 
     * @type {string}
     * @memberof Ticker
     */
    'lastPrice': string;
    /**
     * 
     * @type {string}
     * @memberof Ticker
     */
    'bestAskPrice': string;
    /**
     * 
     * @type {string}
     * @memberof Ticker
     */
    'bestBidPrice': string;
    /**
     * 
     * @type {string}
     * @memberof Ticker
     */
    'indexPrice': string;
}
/**
 * 
 * @export
 * @interface Ticker200Response
 */
export interface Ticker200Response {
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof Ticker200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TimeInForce = {
    Gtt: 'GTT',
    Ioc: 'IOC',
    Fok: 'FOK'
} as const;

export type TimeInForce = typeof TimeInForce[keyof typeof TimeInForce];


/**
 * 
 * @export
 * @enum {string}
 */

export const TimeInterval = {
    _1m: '1m',
    _3m: '3m',
    _5m: '5m',
    _15m: '15m',
    _30m: '30m',
    _1h: '1h',
    _2h: '2h',
    _4h: '4h',
    _6h: '6h',
    _8h: '8h',
    _12h: '12h',
    _1d: '1d',
    _3d: '3d',
    _1w: '1w',
    _1M: '1M',
    _3M: '3M',
    _1y: '1y'
} as const;

export type TimeInterval = typeof TimeInterval[keyof typeof TimeInterval];


/**
 * 
 * @export
 * @interface TradeAllianceMemberOverviewDTO
 */
export interface TradeAllianceMemberOverviewDTO {
    /**
     * 
     * @type {string}
     * @memberof TradeAllianceMemberOverviewDTO
     */
    'totalTradingVolume': string;
    /**
     * 
     * @type {MileStone}
     * @memberof TradeAllianceMemberOverviewDTO
     */
    'maxMilestoneAchieved': MileStone;
    /**
     * 
     * @type {string}
     * @memberof TradeAllianceMemberOverviewDTO
     */
    'totalTradingPoints': string;
}


/**
 * 
 * @export
 * @interface TradeAlliancePartnerDetailsDTO
 */
export interface TradeAlliancePartnerDetailsDTO {
    /**
     * 
     * @type {string}
     * @memberof TradeAlliancePartnerDetailsDTO
     */
    'refereesAcceptedCount': string;
    /**
     * 
     * @type {string}
     * @memberof TradeAlliancePartnerDetailsDTO
     */
    'refereeDepositedCount': string;
    /**
     * 
     * @type {string}
     * @memberof TradeAlliancePartnerDetailsDTO
     */
    'milestoneAchievedCount': string;
    /**
     * 
     * @type {string}
     * @memberof TradeAlliancePartnerDetailsDTO
     */
    'totalPartnerPoints': string;
    /**
     * 
     * @type {string}
     * @memberof TradeAlliancePartnerDetailsDTO
     */
    'redeemedTradingPoints'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TradeType = {
    Order: 'Order',
    Liquidation: 'Liquidation',
    Liquidate: 'Liquidate'
} as const;

export type TradeType = typeof TradeType[keyof typeof TradeType];


/**
 * 
 * @export
 * @enum {string}
 */

export const TransferActions = {
    Deposit: 'Deposit',
    Withdraw: 'Withdraw'
} as const;

export type TransferActions = typeof TransferActions[keyof typeof TransferActions];


/**
 * 
 * @export
 * @enum {string}
 */

export const TransferStatuses = {
    Confirmed: 'Confirmed'
} as const;

export type TransferStatuses = typeof TransferStatuses[keyof typeof TransferStatuses];


/**
 * 
 * @export
 * @interface UserAccountPermissionsDto
 */
export interface UserAccountPermissionsDto {
    /**
     * 
     * @type {boolean}
     * @memberof UserAccountPermissionsDto
     */
    'isWhitelisted': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserAccountPermissionsDto
     */
    'isTradeAlliancePartner': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserAccountPermissionsDto
     */
    'isTradeAllianceMember': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserAccountPermissionsDto
     */
    'isAmbassador': boolean;
    /**
     * 
     * @type {VerificationStatus}
     * @memberof UserAccountPermissionsDto
     */
    'verificationStatus': VerificationStatus;
}
/**
 * 
 * @export
 * @interface UserAuthRequest
 */
export interface UserAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof UserAuthRequest
     */
    'userAddress': string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthRequest
     */
    'signature': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthRequest
     */
    'isTermAccepted': boolean;
}
/**
 * 
 * @export
 * @interface UserFundingDTO
 */
export interface UserFundingDTO {
    /**
     * 
     * @type {number}
     * @memberof UserFundingDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserFundingDTO
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof UserFundingDTO
     */
    'userAddress': string;
    /**
     * 
     * @type {string}
     * @memberof UserFundingDTO
     */
    'appliedFundingRate': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserFundingDTO
     */
    'isFundingRatePositive': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserFundingDTO
     */
    'payment': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserFundingDTO
     */
    'isPaymentPositive': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserFundingDTO
     */
    'oraclePrice': string;
    /**
     * 
     * @type {number}
     * @memberof UserFundingDTO
     */
    'blockNumber': number;
    /**
     * 
     * @type {string}
     * @memberof UserFundingDTO
     */
    'quantity': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserFundingDTO
     */
    'isPositionPositive': boolean;
    /**
     * 
     * @type {number}
     * @memberof UserFundingDTO
     */
    'time': number;
    /**
     * 
     * @type {Side}
     * @memberof UserFundingDTO
     */
    'side': Side;
}


/**
 * 
 * @export
 * @interface UserPosition
 */
export interface UserPosition {
    /**
     * 
     * @type {string}
     * @memberof UserPosition
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof UserPosition
     */
    'avgEntryPrice': string;
    /**
     * 
     * @type {string}
     * @memberof UserPosition
     */
    'marginType': string;
    /**
     * 
     * @type {string}
     * @memberof UserPosition
     */
    'userAddress': string;
    /**
     * 
     * @type {string}
     * @memberof UserPosition
     */
    'margin': string;
    /**
     * 
     * @type {string}
     * @memberof UserPosition
     */
    'liquidationPrice': string;
    /**
     * 
     * @type {string}
     * @memberof UserPosition
     */
    'midMarketPrice': string;
    /**
     * 
     * @type {string}
     * @memberof UserPosition
     */
    'positionValue': string;
    /**
     * 
     * @type {string}
     * @memberof UserPosition
     */
    'quantity': string;
    /**
     * 
     * @type {Side}
     * @memberof UserPosition
     */
    'side': Side;
    /**
     * 
     * @type {string}
     * @memberof UserPosition
     */
    'leverage': string;
    /**
     * 
     * @type {string}
     * @memberof UserPosition
     */
    'unrealizedProfit': string;
    /**
     * 
     * @type {string}
     * @memberof UserPosition
     */
    'unrealizedProfitPercent': string;
    /**
     * 
     * @type {string}
     * @memberof UserPosition
     */
    'positionSelectedLeverage': string;
    /**
     * 
     * @type {string}
     * @memberof UserPosition
     */
    'latestTxHash': string;
    /**
     * 
     * @type {number}
     * @memberof UserPosition
     */
    'latestBlockNumber': number;
    /**
     * 
     * @type {string}
     * @memberof UserPosition
     */
    'oraclePrice': string;
    /**
     * 
     * @type {string}
     * @memberof UserPosition
     */
    'indexPrice': string;
}


/**
 * 
 * @export
 * @interface UserTransactionHistoryDTO
 */
export interface UserTransactionHistoryDTO {
    /**
     * 
     * @type {number}
     * @memberof UserTransactionHistoryDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserTransactionHistoryDTO
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof UserTransactionHistoryDTO
     */
    'traderType': string;
    /**
     * 
     * @type {string}
     * @memberof UserTransactionHistoryDTO
     */
    'commission': string;
    /**
     * 
     * @type {string}
     * @memberof UserTransactionHistoryDTO
     */
    'commissionAsset': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserTransactionHistoryDTO
     */
    'maker': boolean;
    /**
     * 
     * @type {Side}
     * @memberof UserTransactionHistoryDTO
     */
    'side': Side;
    /**
     * 
     * @type {string}
     * @memberof UserTransactionHistoryDTO
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof UserTransactionHistoryDTO
     */
    'quantity': string;
    /**
     * 
     * @type {string}
     * @memberof UserTransactionHistoryDTO
     */
    'quoteQty': string;
    /**
     * 
     * @type {string}
     * @memberof UserTransactionHistoryDTO
     */
    'realizedPnl': string;
    /**
     * 
     * @type {string}
     * @memberof UserTransactionHistoryDTO
     */
    'orderHash': string;
    /**
     * 
     * @type {number}
     * @memberof UserTransactionHistoryDTO
     */
    'time': number;
}


/**
 * 
 * @export
 * @interface VerificationStatus
 */
export interface VerificationStatus {
}
/**
 * 
 * @export
 * @interface VerifyDeposit200Response
 */
export interface VerifyDeposit200Response {
    /**
     * 
     * @type {string}
     * @memberof VerifyDeposit200Response
     */
    'verificationStatus': string;
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof VerifyDeposit200Response
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface VerifyDeposit200ResponseAnyOf
 */
export interface VerifyDeposit200ResponseAnyOf {
    /**
     * 
     * @type {string}
     * @memberof VerifyDeposit200ResponseAnyOf
     */
    'verificationStatus': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryAuthorization: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/country`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isWhitelistedAccount: async (userAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAddress' is not null or undefined
            assertParamExists('isWhitelistedAccount', 'userAddress', userAddress)
            const localVarPath = `/whitelistedAccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userAddress !== undefined) {
                localVarQueryParameter['userAddress'] = userAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryAuthorization(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryAuthorization200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryAuthorization(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isWhitelistedAccount(userAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsWhitelistedAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isWhitelistedAccount(userAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryAuthorization(options?: AxiosRequestConfig): AxiosPromise<CountryAuthorization200Response> {
            return localVarFp.countryAuthorization(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthApiIsWhitelistedAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isWhitelistedAccount(requestParameters: AuthApiIsWhitelistedAccountRequest, options?: AxiosRequestConfig): AxiosPromise<IsWhitelistedAccount200Response> {
            return localVarFp.isWhitelistedAccount(requestParameters.userAddress, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for isWhitelistedAccount operation in AuthApi.
 * @export
 * @interface AuthApiIsWhitelistedAccountRequest
 */
export interface AuthApiIsWhitelistedAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthApiIsWhitelistedAccount
     */
    readonly userAddress: string
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public countryAuthorization(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).countryAuthorization(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthApiIsWhitelistedAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public isWhitelistedAccount(requestParameters: AuthApiIsWhitelistedAccountRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).isWhitelistedAccount(requestParameters.userAddress, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigApi - axios parameter creator
 * @export
 */
export const ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuxiliaryAddresses: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuxiliaryAddresses(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAuxiliaryAddresses200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuxiliaryAddresses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuxiliaryAddresses(options?: AxiosRequestConfig): AxiosPromise<GetAuxiliaryAddresses200Response> {
            return localVarFp.getAuxiliaryAddresses(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public getAuxiliaryAddresses(options?: AxiosRequestConfig) {
        return ConfigApiFp(this.configuration).getAuxiliaryAddresses(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FeedbackApi - axios parameter creator
 * @export
 */
export const FeedbackApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FeedbackSubmissionRequest} feedbackSubmissionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedback: async (feedbackSubmissionRequest: FeedbackSubmissionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackSubmissionRequest' is not null or undefined
            assertParamExists('createFeedback', 'feedbackSubmissionRequest', feedbackSubmissionRequest)
            const localVarPath = `/feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(feedbackSubmissionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedbackApi - functional programming interface
 * @export
 */
export const FeedbackApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedbackApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {FeedbackSubmissionRequest} feedbackSubmissionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeedback(feedbackSubmissionRequest: FeedbackSubmissionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFeedback200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeedback(feedbackSubmissionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FeedbackApi - factory interface
 * @export
 */
export const FeedbackApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedbackApiFp(configuration)
    return {
        /**
         * 
         * @param {FeedbackApiCreateFeedbackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedback(requestParameters: FeedbackApiCreateFeedbackRequest, options?: AxiosRequestConfig): AxiosPromise<CreateFeedback200Response> {
            return localVarFp.createFeedback(requestParameters.feedbackSubmissionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createFeedback operation in FeedbackApi.
 * @export
 * @interface FeedbackApiCreateFeedbackRequest
 */
export interface FeedbackApiCreateFeedbackRequest {
    /**
     * 
     * @type {FeedbackSubmissionRequest}
     * @memberof FeedbackApiCreateFeedback
     */
    readonly feedbackSubmissionRequest: FeedbackSubmissionRequest
}

/**
 * FeedbackApi - object-oriented interface
 * @export
 * @class FeedbackApi
 * @extends {BaseAPI}
 */
export class FeedbackApi extends BaseAPI {
    /**
     * 
     * @param {FeedbackApiCreateFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public createFeedback(requestParameters: FeedbackApiCreateFeedbackRequest, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).createFeedback(requestParameters.feedbackSubmissionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MarketApi - axios parameter creator
 * @export
 */
export const MarketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} symbol 
         * @param {TimeInterval} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCandlestickData: async (symbol: string, interval: TimeInterval, startTime?: number, endTime?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getCandlestickData', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getCandlestickData', 'interval', interval)
            const localVarPath = `/candlestickData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractAddresses: async (symbol?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/marketData/contractAddresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfo: async (symbol?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exchangeInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingRate: async (symbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFundingRate', 'symbol', symbol)
            const localVarPath = `/fundingRate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketData: async (symbol?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/marketData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketSymbols: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/marketData/symbols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterInfo: async (symbol?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/masterInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeta: async (symbol?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/meta`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderbook: async (symbol: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOrderbook', 'symbol', symbol)
            const localVarPath = `/orderbook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {string} [traders] 
         * @param {number} [pageSize] 
         * @param {number} [pageNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTrade: async (symbol: string, traders?: string, pageSize?: number, pageNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getRecentTrade', 'symbol', symbol)
            const localVarPath = `/recentTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (traders !== undefined) {
                localVarQueryParameter['traders'] = traders;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MOBILECLIENT} client 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        minimumSupportVersion: async (client: MOBILECLIENT, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'client' is not null or undefined
            assertParamExists('minimumSupportVersion', 'client', client)
            const localVarPath = `/meta/minimumSupportVersion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ticker: async (symbol?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ticker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketApi - functional programming interface
 * @export
 */
export const MarketApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarketApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} symbol 
         * @param {TimeInterval} interval 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCandlestickData(symbol: string, interval: TimeInterval, startTime?: number, endTime?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCandlestickData(symbol, interval, startTime, endTime, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractAddresses(symbol?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContractAddresses200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractAddresses(symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeInfo(symbol?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetExchangeInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeInfo(symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingRate(symbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFundingRate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingRate(symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketData(symbol?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarketData200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketData(symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketSymbols(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarketSymbols200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketSymbols(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterInfo(symbol?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMasterInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMasterInfo(symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMeta(symbol?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMeta200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMeta(symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} symbol 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderbook(symbol: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Orderbook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderbook(symbol, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} symbol 
         * @param {string} [traders] 
         * @param {number} [pageSize] 
         * @param {number} [pageNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentTrade(symbol: string, traders?: string, pageSize?: number, pageNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRecentTrade200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentTrade(symbol, traders, pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MOBILECLIENT} client 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async minimumSupportVersion(client: MOBILECLIENT, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MinimumSupportVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.minimumSupportVersion(client, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ticker(symbol?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ticker200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ticker(symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MarketApi - factory interface
 * @export
 */
export const MarketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarketApiFp(configuration)
    return {
        /**
         * 
         * @param {MarketApiGetCandlestickDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCandlestickData(requestParameters: MarketApiGetCandlestickDataRequest, options?: AxiosRequestConfig): AxiosPromise<Array<any>> {
            return localVarFp.getCandlestickData(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MarketApiGetContractAddressesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractAddresses(requestParameters: MarketApiGetContractAddressesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetContractAddresses200Response> {
            return localVarFp.getContractAddresses(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MarketApiGetExchangeInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfo(requestParameters: MarketApiGetExchangeInfoRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetExchangeInfo200Response> {
            return localVarFp.getExchangeInfo(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeStatus(options?: AxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.getExchangeStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MarketApiGetFundingRateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingRate(requestParameters: MarketApiGetFundingRateRequest, options?: AxiosRequestConfig): AxiosPromise<GetFundingRate200Response> {
            return localVarFp.getFundingRate(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MarketApiGetMarketDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketData(requestParameters: MarketApiGetMarketDataRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetMarketData200Response> {
            return localVarFp.getMarketData(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketSymbols(options?: AxiosRequestConfig): AxiosPromise<GetMarketSymbols200Response> {
            return localVarFp.getMarketSymbols(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MarketApiGetMasterInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterInfo(requestParameters: MarketApiGetMasterInfoRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetMasterInfo200Response> {
            return localVarFp.getMasterInfo(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MarketApiGetMetaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeta(requestParameters: MarketApiGetMetaRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetMeta200Response> {
            return localVarFp.getMeta(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MarketApiGetOrderbookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderbook(requestParameters: MarketApiGetOrderbookRequest, options?: AxiosRequestConfig): AxiosPromise<Orderbook> {
            return localVarFp.getOrderbook(requestParameters.symbol, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MarketApiGetRecentTradeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTrade(requestParameters: MarketApiGetRecentTradeRequest, options?: AxiosRequestConfig): AxiosPromise<GetRecentTrade200Response> {
            return localVarFp.getRecentTrade(requestParameters.symbol, requestParameters.traders, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MarketApiMinimumSupportVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        minimumSupportVersion(requestParameters: MarketApiMinimumSupportVersionRequest, options?: AxiosRequestConfig): AxiosPromise<MinimumSupportVersion200Response> {
            return localVarFp.minimumSupportVersion(requestParameters.client, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MarketApiTickerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ticker(requestParameters: MarketApiTickerRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Ticker200Response> {
            return localVarFp.ticker(requestParameters.symbol, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getCandlestickData operation in MarketApi.
 * @export
 * @interface MarketApiGetCandlestickDataRequest
 */
export interface MarketApiGetCandlestickDataRequest {
    /**
     * 
     * @type {string}
     * @memberof MarketApiGetCandlestickData
     */
    readonly symbol: string

    /**
     * 
     * @type {TimeInterval}
     * @memberof MarketApiGetCandlestickData
     */
    readonly interval: TimeInterval

    /**
     * 
     * @type {number}
     * @memberof MarketApiGetCandlestickData
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketApiGetCandlestickData
     */
    readonly endTime?: number

    /**
     * 
     * @type {number}
     * @memberof MarketApiGetCandlestickData
     */
    readonly limit?: number
}

/**
 * Request parameters for getContractAddresses operation in MarketApi.
 * @export
 * @interface MarketApiGetContractAddressesRequest
 */
export interface MarketApiGetContractAddressesRequest {
    /**
     * 
     * @type {string}
     * @memberof MarketApiGetContractAddresses
     */
    readonly symbol?: string
}

/**
 * Request parameters for getExchangeInfo operation in MarketApi.
 * @export
 * @interface MarketApiGetExchangeInfoRequest
 */
export interface MarketApiGetExchangeInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof MarketApiGetExchangeInfo
     */
    readonly symbol?: string
}

/**
 * Request parameters for getFundingRate operation in MarketApi.
 * @export
 * @interface MarketApiGetFundingRateRequest
 */
export interface MarketApiGetFundingRateRequest {
    /**
     * 
     * @type {string}
     * @memberof MarketApiGetFundingRate
     */
    readonly symbol: string
}

/**
 * Request parameters for getMarketData operation in MarketApi.
 * @export
 * @interface MarketApiGetMarketDataRequest
 */
export interface MarketApiGetMarketDataRequest {
    /**
     * 
     * @type {string}
     * @memberof MarketApiGetMarketData
     */
    readonly symbol?: string
}

/**
 * Request parameters for getMasterInfo operation in MarketApi.
 * @export
 * @interface MarketApiGetMasterInfoRequest
 */
export interface MarketApiGetMasterInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof MarketApiGetMasterInfo
     */
    readonly symbol?: string
}

/**
 * Request parameters for getMeta operation in MarketApi.
 * @export
 * @interface MarketApiGetMetaRequest
 */
export interface MarketApiGetMetaRequest {
    /**
     * 
     * @type {string}
     * @memberof MarketApiGetMeta
     */
    readonly symbol?: string
}

/**
 * Request parameters for getOrderbook operation in MarketApi.
 * @export
 * @interface MarketApiGetOrderbookRequest
 */
export interface MarketApiGetOrderbookRequest {
    /**
     * 
     * @type {string}
     * @memberof MarketApiGetOrderbook
     */
    readonly symbol: string

    /**
     * 
     * @type {number}
     * @memberof MarketApiGetOrderbook
     */
    readonly limit?: number
}

/**
 * Request parameters for getRecentTrade operation in MarketApi.
 * @export
 * @interface MarketApiGetRecentTradeRequest
 */
export interface MarketApiGetRecentTradeRequest {
    /**
     * 
     * @type {string}
     * @memberof MarketApiGetRecentTrade
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof MarketApiGetRecentTrade
     */
    readonly traders?: string

    /**
     * 
     * @type {number}
     * @memberof MarketApiGetRecentTrade
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof MarketApiGetRecentTrade
     */
    readonly pageNumber?: number
}

/**
 * Request parameters for minimumSupportVersion operation in MarketApi.
 * @export
 * @interface MarketApiMinimumSupportVersionRequest
 */
export interface MarketApiMinimumSupportVersionRequest {
    /**
     * 
     * @type {MOBILECLIENT}
     * @memberof MarketApiMinimumSupportVersion
     */
    readonly client: MOBILECLIENT
}

/**
 * Request parameters for ticker operation in MarketApi.
 * @export
 * @interface MarketApiTickerRequest
 */
export interface MarketApiTickerRequest {
    /**
     * 
     * @type {string}
     * @memberof MarketApiTicker
     */
    readonly symbol?: string
}

/**
 * MarketApi - object-oriented interface
 * @export
 * @class MarketApi
 * @extends {BaseAPI}
 */
export class MarketApi extends BaseAPI {
    /**
     * 
     * @param {MarketApiGetCandlestickDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getCandlestickData(requestParameters: MarketApiGetCandlestickDataRequest, options?: AxiosRequestConfig) {
        return MarketApiFp(this.configuration).getCandlestickData(requestParameters.symbol, requestParameters.interval, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MarketApiGetContractAddressesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getContractAddresses(requestParameters: MarketApiGetContractAddressesRequest = {}, options?: AxiosRequestConfig) {
        return MarketApiFp(this.configuration).getContractAddresses(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MarketApiGetExchangeInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getExchangeInfo(requestParameters: MarketApiGetExchangeInfoRequest = {}, options?: AxiosRequestConfig) {
        return MarketApiFp(this.configuration).getExchangeInfo(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getExchangeStatus(options?: AxiosRequestConfig) {
        return MarketApiFp(this.configuration).getExchangeStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MarketApiGetFundingRateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getFundingRate(requestParameters: MarketApiGetFundingRateRequest, options?: AxiosRequestConfig) {
        return MarketApiFp(this.configuration).getFundingRate(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MarketApiGetMarketDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getMarketData(requestParameters: MarketApiGetMarketDataRequest = {}, options?: AxiosRequestConfig) {
        return MarketApiFp(this.configuration).getMarketData(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getMarketSymbols(options?: AxiosRequestConfig) {
        return MarketApiFp(this.configuration).getMarketSymbols(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MarketApiGetMasterInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getMasterInfo(requestParameters: MarketApiGetMasterInfoRequest = {}, options?: AxiosRequestConfig) {
        return MarketApiFp(this.configuration).getMasterInfo(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MarketApiGetMetaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getMeta(requestParameters: MarketApiGetMetaRequest = {}, options?: AxiosRequestConfig) {
        return MarketApiFp(this.configuration).getMeta(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MarketApiGetOrderbookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getOrderbook(requestParameters: MarketApiGetOrderbookRequest, options?: AxiosRequestConfig) {
        return MarketApiFp(this.configuration).getOrderbook(requestParameters.symbol, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MarketApiGetRecentTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getRecentTrade(requestParameters: MarketApiGetRecentTradeRequest, options?: AxiosRequestConfig) {
        return MarketApiFp(this.configuration).getRecentTrade(requestParameters.symbol, requestParameters.traders, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MarketApiMinimumSupportVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public minimumSupportVersion(requestParameters: MarketApiMinimumSupportVersionRequest, options?: AxiosRequestConfig) {
        return MarketApiFp(this.configuration).minimumSupportVersion(requestParameters.client, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MarketApiTickerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public ticker(requestParameters: MarketApiTickerRequest = {}, options?: AxiosRequestConfig) {
        return MarketApiFp(this.configuration).ticker(requestParameters.symbol, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MiscApi - axios parameter creator
 * @export
 */
export const MiscApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscApi - functional programming interface
 * @export
 */
export const MiscApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiscApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MiscApi - factory interface
 * @export
 */
export const MiscApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiscApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(options?: AxiosRequestConfig): AxiosPromise<Get200Response> {
            return localVarFp.get(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiscApi - object-oriented interface
 * @export
 * @class MiscApi
 * @extends {BaseAPI}
 */
export class MiscApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    public get(options?: AxiosRequestConfig) {
        return MiscApiFp(this.configuration).get(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OrderBodyAttributes} orderBodyAttributes 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder: async (orderBodyAttributes: OrderBodyAttributes, userAgent?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderBodyAttributes' is not null or undefined
            assertParamExists('createOrder', 'orderBodyAttributes', orderBodyAttributes)
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userAgent != null) {
                localVarHeaderParameter['user-agent'] = String(userAgent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderBodyAttributes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OrderBodyAttributes} orderBodyAttributes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder: async (orderBodyAttributes: OrderBodyAttributes, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderBodyAttributes' is not null or undefined
            assertParamExists('deleteOrder', 'orderBodyAttributes', orderBodyAttributes)
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderBodyAttributes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteOrdersParam} deleteOrdersParam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrders: async (deleteOrdersParam: DeleteOrdersParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteOrdersParam' is not null or undefined
            assertParamExists('deleteOrders', 'deleteOrdersParam', deleteOrdersParam)
            const localVarPath = `/orders/hash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteOrdersParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {OrderBodyAttributes} orderBodyAttributes 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrder(orderBodyAttributes: OrderBodyAttributes, userAgent?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrder201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrder(orderBodyAttributes, userAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OrderBodyAttributes} orderBodyAttributes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrder(orderBodyAttributes: OrderBodyAttributes, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrder(orderBodyAttributes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DeleteOrdersParam} deleteOrdersParam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrders(deleteOrdersParam: DeleteOrdersParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteOrders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrders(deleteOrdersParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * 
         * @param {OrdersApiCreateOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(requestParameters: OrdersApiCreateOrderRequest, options?: AxiosRequestConfig): AxiosPromise<CreateOrder201Response> {
            return localVarFp.createOrder(requestParameters.orderBodyAttributes, requestParameters.userAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OrdersApiDeleteOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(requestParameters: OrdersApiDeleteOrderRequest, options?: AxiosRequestConfig): AxiosPromise<DeleteOrder200Response> {
            return localVarFp.deleteOrder(requestParameters.orderBodyAttributes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OrdersApiDeleteOrdersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrders(requestParameters: OrdersApiDeleteOrdersRequest, options?: AxiosRequestConfig): AxiosPromise<DeleteOrders200Response> {
            return localVarFp.deleteOrders(requestParameters.deleteOrdersParam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createOrder operation in OrdersApi.
 * @export
 * @interface OrdersApiCreateOrderRequest
 */
export interface OrdersApiCreateOrderRequest {
    /**
     * 
     * @type {OrderBodyAttributes}
     * @memberof OrdersApiCreateOrder
     */
    readonly orderBodyAttributes: OrderBodyAttributes

    /**
     * 
     * @type {string}
     * @memberof OrdersApiCreateOrder
     */
    readonly userAgent?: string
}

/**
 * Request parameters for deleteOrder operation in OrdersApi.
 * @export
 * @interface OrdersApiDeleteOrderRequest
 */
export interface OrdersApiDeleteOrderRequest {
    /**
     * 
     * @type {OrderBodyAttributes}
     * @memberof OrdersApiDeleteOrder
     */
    readonly orderBodyAttributes: OrderBodyAttributes
}

/**
 * Request parameters for deleteOrders operation in OrdersApi.
 * @export
 * @interface OrdersApiDeleteOrdersRequest
 */
export interface OrdersApiDeleteOrdersRequest {
    /**
     * 
     * @type {DeleteOrdersParam}
     * @memberof OrdersApiDeleteOrders
     */
    readonly deleteOrdersParam: DeleteOrdersParam
}

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * 
     * @param {OrdersApiCreateOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public createOrder(requestParameters: OrdersApiCreateOrderRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).createOrder(requestParameters.orderBodyAttributes, requestParameters.userAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OrdersApiDeleteOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public deleteOrder(requestParameters: OrdersApiDeleteOrderRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).deleteOrder(requestParameters.orderBodyAttributes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OrdersApiDeleteOrdersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public deleteOrders(requestParameters: OrdersApiDeleteOrdersRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).deleteOrders(requestParameters.deleteOrdersParam, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TAReferralApi - axios parameter creator
 * @export
 */
export const TAReferralApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateReferralLink: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tareferral/genReferral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDetails: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tareferral/getMemberDetails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersMonthlyOverview: async (pageSize?: number, cursor?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tareferral/getMembersMonthlyOverview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartnerDetails: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tareferral/getPartnerDetails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [pageNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefereeDetailsByPartner: async (pageSize?: number, pageNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tareferral/getRefereesByPartner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferralDetails: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tareferral/getReferralDetails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TAReferralBodyAttributes} tAReferralBodyAttributes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAccount: async (tAReferralBodyAttributes: TAReferralBodyAttributes, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tAReferralBodyAttributes' is not null or undefined
            assertParamExists('linkAccount', 'tAReferralBodyAttributes', tAReferralBodyAttributes)
            const localVarPath = `/tareferral/linkAccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tAReferralBodyAttributes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TAReferralApi - functional programming interface
 * @export
 */
export const TAReferralApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TAReferralApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateReferralLink(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TAReferralCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateReferralLink(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberDetails(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeAllianceMemberOverviewDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberDetails(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMembersMonthlyOverview(pageSize?: number, cursor?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListingWithCursorITradeAllianceMemberMonthlyOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMembersMonthlyOverview(pageSize, cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartnerDetails(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeAlliancePartnerDetailsDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartnerDetails(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [pageNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRefereeDetailsByPartner(pageSize?: number, pageNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerRefereeDetailsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRefereeDetailsByPartner(pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferralDetails(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TAReferralCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferralDetails(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TAReferralBodyAttributes} tAReferralBodyAttributes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkAccount(tAReferralBodyAttributes: TAReferralBodyAttributes, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkAccount(tAReferralBodyAttributes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TAReferralApi - factory interface
 * @export
 */
export const TAReferralApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TAReferralApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateReferralLink(options?: AxiosRequestConfig): AxiosPromise<TAReferralCodeResponse> {
            return localVarFp.generateReferralLink(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDetails(options?: AxiosRequestConfig): AxiosPromise<TradeAllianceMemberOverviewDTO> {
            return localVarFp.getMemberDetails(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TAReferralApiGetMembersMonthlyOverviewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersMonthlyOverview(requestParameters: TAReferralApiGetMembersMonthlyOverviewRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ListingWithCursorITradeAllianceMemberMonthlyOverview> {
            return localVarFp.getMembersMonthlyOverview(requestParameters.pageSize, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartnerDetails(options?: AxiosRequestConfig): AxiosPromise<TradeAlliancePartnerDetailsDTO> {
            return localVarFp.getPartnerDetails(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TAReferralApiGetRefereeDetailsByPartnerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefereeDetailsByPartner(requestParameters: TAReferralApiGetRefereeDetailsByPartnerRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PartnerRefereeDetailsDto> {
            return localVarFp.getRefereeDetailsByPartner(requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferralDetails(options?: AxiosRequestConfig): AxiosPromise<TAReferralCodeResponse> {
            return localVarFp.getReferralDetails(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TAReferralApiLinkAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAccount(requestParameters: TAReferralApiLinkAccountRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.linkAccount(requestParameters.tAReferralBodyAttributes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMembersMonthlyOverview operation in TAReferralApi.
 * @export
 * @interface TAReferralApiGetMembersMonthlyOverviewRequest
 */
export interface TAReferralApiGetMembersMonthlyOverviewRequest {
    /**
     * 
     * @type {number}
     * @memberof TAReferralApiGetMembersMonthlyOverview
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof TAReferralApiGetMembersMonthlyOverview
     */
    readonly cursor?: number
}

/**
 * Request parameters for getRefereeDetailsByPartner operation in TAReferralApi.
 * @export
 * @interface TAReferralApiGetRefereeDetailsByPartnerRequest
 */
export interface TAReferralApiGetRefereeDetailsByPartnerRequest {
    /**
     * 
     * @type {number}
     * @memberof TAReferralApiGetRefereeDetailsByPartner
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof TAReferralApiGetRefereeDetailsByPartner
     */
    readonly pageNumber?: number
}

/**
 * Request parameters for linkAccount operation in TAReferralApi.
 * @export
 * @interface TAReferralApiLinkAccountRequest
 */
export interface TAReferralApiLinkAccountRequest {
    /**
     * 
     * @type {TAReferralBodyAttributes}
     * @memberof TAReferralApiLinkAccount
     */
    readonly tAReferralBodyAttributes: TAReferralBodyAttributes
}

/**
 * TAReferralApi - object-oriented interface
 * @export
 * @class TAReferralApi
 * @extends {BaseAPI}
 */
export class TAReferralApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TAReferralApi
     */
    public generateReferralLink(options?: AxiosRequestConfig) {
        return TAReferralApiFp(this.configuration).generateReferralLink(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TAReferralApi
     */
    public getMemberDetails(options?: AxiosRequestConfig) {
        return TAReferralApiFp(this.configuration).getMemberDetails(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TAReferralApiGetMembersMonthlyOverviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TAReferralApi
     */
    public getMembersMonthlyOverview(requestParameters: TAReferralApiGetMembersMonthlyOverviewRequest = {}, options?: AxiosRequestConfig) {
        return TAReferralApiFp(this.configuration).getMembersMonthlyOverview(requestParameters.pageSize, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TAReferralApi
     */
    public getPartnerDetails(options?: AxiosRequestConfig) {
        return TAReferralApiFp(this.configuration).getPartnerDetails(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TAReferralApiGetRefereeDetailsByPartnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TAReferralApi
     */
    public getRefereeDetailsByPartner(requestParameters: TAReferralApiGetRefereeDetailsByPartnerRequest = {}, options?: AxiosRequestConfig) {
        return TAReferralApiFp(this.configuration).getRefereeDetailsByPartner(requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TAReferralApi
     */
    public getReferralDetails(options?: AxiosRequestConfig) {
        return TAReferralApiFp(this.configuration).getReferralDetails(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TAReferralApiLinkAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TAReferralApi
     */
    public linkAccount(requestParameters: TAReferralApiLinkAccountRequest, options?: AxiosRequestConfig) {
        return TAReferralApiFp(this.configuration).linkAccount(requestParameters.tAReferralBodyAttributes, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AdjustLeverageRequest} adjustLeverageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustLeverage: async (adjustLeverageRequest: AdjustLeverageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adjustLeverageRequest' is not null or undefined
            assertParamExists('adjustLeverage', 'adjustLeverageRequest', adjustLeverageRequest)
            const localVarPath = `/account/adjustLeverage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adjustLeverageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserAuthRequest} userAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auth: async (userAuthRequest: UserAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAuthRequest' is not null or undefined
            assertParamExists('auth', 'userAuthRequest', userAuthRequest)
            const localVarPath = `/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FaucetRequest} faucetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faucet: async (faucetRequest: FaucetRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'faucetRequest' is not null or undefined
            assertParamExists('faucet', 'faucetRequest', faucetRequest)
            const localVarPath = `/account/faucet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(faucetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fundGas: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/fundGas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [parentAddress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (parentAddress?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (parentAddress !== undefined) {
                localVarQueryParameter['parentAddress'] = parentAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountPermissions: async (userAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAddress' is not null or undefined
            assertParamExists('getAccountPermissions', 'userAddress', userAddress)
            const localVarPath = `/account/getAccountPermissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userAddress !== undefined) {
                localVarQueryParameter['userAddress'] = userAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} startTime 
         * @param {AccountValueTimeInterval} interval 
         * @param {number} endTime 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountValueOverTime: async (startTime: number, interval: AccountValueTimeInterval, endTime: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getAccountValueOverTime', 'startTime', startTime)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getAccountValueOverTime', 'interval', interval)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getAccountValueOverTime', 'endTime', endTime)
            const localVarPath = `/account/value-graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {string} [parentAddress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrder: async (symbol?: string, parentAddress?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/open-orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (parentAddress !== undefined) {
                localVarQueryParameter['parentAddress'] = parentAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {string} [parentAddress] 
         * @param {number} [orderId] 
         * @param {Array<string>} [orderHashes] 
         * @param {Array<OrderType>} [orderType] 
         * @param {Array<OrderStatus>} [statuses] 
         * @param {number} [pageSize] 
         * @param {number} [pageNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder: async (symbol?: string, parentAddress?: string, orderId?: number, orderHashes?: Array<string>, orderType?: Array<OrderType>, statuses?: Array<OrderStatus>, pageSize?: number, pageNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (parentAddress !== undefined) {
                localVarQueryParameter['parentAddress'] = parentAddress;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (orderHashes) {
                localVarQueryParameter['orderHashes'] = orderHashes;
            }

            if (orderType) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {number} [orderId] 
         * @param {Array<string>} [orderHashes] 
         * @param {Array<OrderStatus>} [limitStatuses] 
         * @param {Array<OrderStatus>} [marketStatuses] 
         * @param {number} [pageSize] 
         * @param {number} [pageNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersByOrderType: async (symbol?: string, orderId?: number, orderHashes?: Array<string>, limitStatuses?: Array<OrderStatus>, marketStatuses?: Array<OrderStatus>, pageSize?: number, pageNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/by-order-type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (orderHashes) {
                localVarQueryParameter['orderHashes'] = orderHashes;
            }

            if (limitStatuses) {
                localVarQueryParameter['limitStatuses'] = limitStatuses;
            }

            if (marketStatuses) {
                localVarQueryParameter['marketStatuses'] = marketStatuses;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [cursor] 
         * @param {string} [symbol] 
         * @param {string} [parentAddress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFundingHistory: async (pageSize?: number, cursor?: number, symbol?: string, parentAddress?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/userFundingHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (parentAddress !== undefined) {
                localVarQueryParameter['parentAddress'] = parentAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {string} [parentAddress] 
         * @param {number} [pageSize] 
         * @param {number} [pageNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPosition: async (symbol?: string, parentAddress?: string, pageSize?: number, pageNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/userPosition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (parentAddress !== undefined) {
                localVarQueryParameter['parentAddress'] = parentAddress;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {string} [parentAddress] 
         * @param {boolean} [maker] 
         * @param {OrderType} [orderType] 
         * @param {number} [fromId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [pageSize] 
         * @param {number} [pageNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTrade: async (symbol?: string, parentAddress?: string, maker?: boolean, orderType?: OrderType, fromId?: number, startTime?: number, endTime?: number, pageSize?: number, pageNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/userTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (parentAddress !== undefined) {
                localVarQueryParameter['parentAddress'] = parentAddress;
            }

            if (maker !== undefined) {
                localVarQueryParameter['maker'] = maker;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {boolean} [maker] 
         * @param {OrderType} [orderType] 
         * @param {number} [fromId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] 
         * @param {number} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTradeHistory: async (symbol?: string, maker?: boolean, orderType?: OrderType, fromId?: number, startTime?: number, endTime?: number, limit?: number, cursor?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/userTradesHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (maker !== undefined) {
                localVarQueryParameter['maker'] = maker;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTraderOverView: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/historicalOverview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {number} [pageSize] 
         * @param {number} [pageNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransactionHistory: async (symbol?: string, pageSize?: number, pageNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/userTransactionHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [cursor] 
         * @param {TransferActions} [action] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransfer: async (pageSize?: number, cursor?: number, action?: TransferActions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/userTransferHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} depositAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyDeposit: async (depositAmount: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'depositAmount' is not null or undefined
            assertParamExists('verifyDeposit', 'depositAmount', depositAmount)
            const localVarPath = `/account/verifyDeposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (depositAmount !== undefined) {
                localVarQueryParameter['depositAmount'] = depositAmount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AdjustLeverageRequest} adjustLeverageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adjustLeverage(adjustLeverageRequest: AdjustLeverageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdjustLeverage200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adjustLeverage(adjustLeverageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UserAuthRequest} userAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auth(userAuthRequest: UserAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Auth200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.auth(userAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {FaucetRequest} faucetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async faucet(faucetRequest: FaucetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Faucet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.faucet(faucetRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fundGas(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Faucet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fundGas(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [parentAddress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(parentAddress?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(parentAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountPermissions(userAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAccountPermissionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountPermissions(userAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} startTime 
         * @param {AccountValueTimeInterval} interval 
         * @param {number} endTime 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountValueOverTime(startTime: number, interval: AccountValueTimeInterval, endTime: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Faucet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountValueOverTime(startTime, interval, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {string} [parentAddress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenOrder(symbol?: string, parentAddress?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenOrder(symbol, parentAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {string} [parentAddress] 
         * @param {number} [orderId] 
         * @param {Array<string>} [orderHashes] 
         * @param {Array<OrderType>} [orderType] 
         * @param {Array<OrderStatus>} [statuses] 
         * @param {number} [pageSize] 
         * @param {number} [pageNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrder(symbol?: string, parentAddress?: string, orderId?: number, orderHashes?: Array<string>, orderType?: Array<OrderType>, statuses?: Array<OrderStatus>, pageSize?: number, pageNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrder(symbol, parentAddress, orderId, orderHashes, orderType, statuses, pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {number} [orderId] 
         * @param {Array<string>} [orderHashes] 
         * @param {Array<OrderStatus>} [limitStatuses] 
         * @param {Array<OrderStatus>} [marketStatuses] 
         * @param {number} [pageSize] 
         * @param {number} [pageNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersByOrderType(symbol?: string, orderId?: number, orderHashes?: Array<string>, limitStatuses?: Array<OrderStatus>, marketStatuses?: Array<OrderStatus>, pageSize?: number, pageNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrdersByOrderType(symbol, orderId, orderHashes, limitStatuses, marketStatuses, pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [cursor] 
         * @param {string} [symbol] 
         * @param {string} [parentAddress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFundingHistory(pageSize?: number, cursor?: number, symbol?: string, parentAddress?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserFundingHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFundingHistory(pageSize, cursor, symbol, parentAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {string} [parentAddress] 
         * @param {number} [pageSize] 
         * @param {number} [pageNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPosition(symbol?: string, parentAddress?: string, pageSize?: number, pageNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserPosition200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPosition(symbol, parentAddress, pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {string} [parentAddress] 
         * @param {boolean} [maker] 
         * @param {OrderType} [orderType] 
         * @param {number} [fromId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [pageSize] 
         * @param {number} [pageNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTrade(symbol?: string, parentAddress?: string, maker?: boolean, orderType?: OrderType, fromId?: number, startTime?: number, endTime?: number, pageSize?: number, pageNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTrade200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTrade(symbol, parentAddress, maker, orderType, fromId, startTime, endTime, pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {boolean} [maker] 
         * @param {OrderType} [orderType] 
         * @param {number} [fromId] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] 
         * @param {number} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTradeHistory(symbol?: string, maker?: boolean, orderType?: OrderType, fromId?: number, startTime?: number, endTime?: number, limit?: number, cursor?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTradeHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTradeHistory(symbol, maker, orderType, fromId, startTime, endTime, limit, cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTraderOverView(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IUserTradeOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTraderOverView(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {number} [pageSize] 
         * @param {number} [pageNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTransactionHistory(symbol?: string, pageSize?: number, pageNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTransactionHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTransactionHistory(symbol, pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [cursor] 
         * @param {TransferActions} [action] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTransfer(pageSize?: number, cursor?: number, action?: TransferActions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTransfer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTransfer(pageSize, cursor, action, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} depositAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyDeposit(depositAmount: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyDeposit200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyDeposit(depositAmount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {UserApiAdjustLeverageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustLeverage(requestParameters: UserApiAdjustLeverageRequest, options?: AxiosRequestConfig): AxiosPromise<AdjustLeverage200Response> {
            return localVarFp.adjustLeverage(requestParameters.adjustLeverageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiAuthRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auth(requestParameters: UserApiAuthRequest, options?: AxiosRequestConfig): AxiosPromise<Auth200Response> {
            return localVarFp.auth(requestParameters.userAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiFaucetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faucet(requestParameters: UserApiFaucetRequest, options?: AxiosRequestConfig): AxiosPromise<Faucet200Response> {
            return localVarFp.faucet(requestParameters.faucetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fundGas(options?: AxiosRequestConfig): AxiosPromise<Faucet200Response> {
            return localVarFp.fundGas(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiGetAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(requestParameters: UserApiGetAccountRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetAccount200Response> {
            return localVarFp.getAccount(requestParameters.parentAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiGetAccountPermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountPermissions(requestParameters: UserApiGetAccountPermissionsRequest, options?: AxiosRequestConfig): AxiosPromise<UserAccountPermissionsDto> {
            return localVarFp.getAccountPermissions(requestParameters.userAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiGetAccountValueOverTimeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountValueOverTime(requestParameters: UserApiGetAccountValueOverTimeRequest, options?: AxiosRequestConfig): AxiosPromise<Faucet200Response> {
            return localVarFp.getAccountValueOverTime(requestParameters.startTime, requestParameters.interval, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiGetOpenOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrder(requestParameters: UserApiGetOpenOrderRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetOrder200Response> {
            return localVarFp.getOpenOrder(requestParameters.symbol, requestParameters.parentAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiGetOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(requestParameters: UserApiGetOrderRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetOrder200Response> {
            return localVarFp.getOrder(requestParameters.symbol, requestParameters.parentAddress, requestParameters.orderId, requestParameters.orderHashes, requestParameters.orderType, requestParameters.statuses, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiGetOrdersByOrderTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersByOrderType(requestParameters: UserApiGetOrdersByOrderTypeRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetOrder200Response> {
            return localVarFp.getOrdersByOrderType(requestParameters.symbol, requestParameters.orderId, requestParameters.orderHashes, requestParameters.limitStatuses, requestParameters.marketStatuses, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiGetUserFundingHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFundingHistory(requestParameters: UserApiGetUserFundingHistoryRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetUserFundingHistory200Response> {
            return localVarFp.getUserFundingHistory(requestParameters.pageSize, requestParameters.cursor, requestParameters.symbol, requestParameters.parentAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiGetUserPositionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPosition(requestParameters: UserApiGetUserPositionRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetUserPosition200Response> {
            return localVarFp.getUserPosition(requestParameters.symbol, requestParameters.parentAddress, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiGetUserTradeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTrade(requestParameters: UserApiGetUserTradeRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetUserTrade200Response> {
            return localVarFp.getUserTrade(requestParameters.symbol, requestParameters.parentAddress, requestParameters.maker, requestParameters.orderType, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiGetUserTradeHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTradeHistory(requestParameters: UserApiGetUserTradeHistoryRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetUserTradeHistory200Response> {
            return localVarFp.getUserTradeHistory(requestParameters.symbol, requestParameters.maker, requestParameters.orderType, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTraderOverView(options?: AxiosRequestConfig): AxiosPromise<IUserTradeOverview> {
            return localVarFp.getUserTraderOverView(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiGetUserTransactionHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransactionHistory(requestParameters: UserApiGetUserTransactionHistoryRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetUserTransactionHistory200Response> {
            return localVarFp.getUserTransactionHistory(requestParameters.symbol, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiGetUserTransferRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransfer(requestParameters: UserApiGetUserTransferRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetUserTransfer200Response> {
            return localVarFp.getUserTransfer(requestParameters.pageSize, requestParameters.cursor, requestParameters.action, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiVerifyDepositRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyDeposit(requestParameters: UserApiVerifyDepositRequest, options?: AxiosRequestConfig): AxiosPromise<VerifyDeposit200Response> {
            return localVarFp.verifyDeposit(requestParameters.depositAmount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for adjustLeverage operation in UserApi.
 * @export
 * @interface UserApiAdjustLeverageRequest
 */
export interface UserApiAdjustLeverageRequest {
    /**
     * 
     * @type {AdjustLeverageRequest}
     * @memberof UserApiAdjustLeverage
     */
    readonly adjustLeverageRequest: AdjustLeverageRequest
}

/**
 * Request parameters for auth operation in UserApi.
 * @export
 * @interface UserApiAuthRequest
 */
export interface UserApiAuthRequest {
    /**
     * 
     * @type {UserAuthRequest}
     * @memberof UserApiAuth
     */
    readonly userAuthRequest: UserAuthRequest
}

/**
 * Request parameters for faucet operation in UserApi.
 * @export
 * @interface UserApiFaucetRequest
 */
export interface UserApiFaucetRequest {
    /**
     * 
     * @type {FaucetRequest}
     * @memberof UserApiFaucet
     */
    readonly faucetRequest: FaucetRequest
}

/**
 * Request parameters for getAccount operation in UserApi.
 * @export
 * @interface UserApiGetAccountRequest
 */
export interface UserApiGetAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiGetAccount
     */
    readonly parentAddress?: string
}

/**
 * Request parameters for getAccountPermissions operation in UserApi.
 * @export
 * @interface UserApiGetAccountPermissionsRequest
 */
export interface UserApiGetAccountPermissionsRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiGetAccountPermissions
     */
    readonly userAddress: string
}

/**
 * Request parameters for getAccountValueOverTime operation in UserApi.
 * @export
 * @interface UserApiGetAccountValueOverTimeRequest
 */
export interface UserApiGetAccountValueOverTimeRequest {
    /**
     * 
     * @type {number}
     * @memberof UserApiGetAccountValueOverTime
     */
    readonly startTime: number

    /**
     * 
     * @type {AccountValueTimeInterval}
     * @memberof UserApiGetAccountValueOverTime
     */
    readonly interval: AccountValueTimeInterval

    /**
     * 
     * @type {number}
     * @memberof UserApiGetAccountValueOverTime
     */
    readonly endTime: number
}

/**
 * Request parameters for getOpenOrder operation in UserApi.
 * @export
 * @interface UserApiGetOpenOrderRequest
 */
export interface UserApiGetOpenOrderRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiGetOpenOrder
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof UserApiGetOpenOrder
     */
    readonly parentAddress?: string
}

/**
 * Request parameters for getOrder operation in UserApi.
 * @export
 * @interface UserApiGetOrderRequest
 */
export interface UserApiGetOrderRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiGetOrder
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof UserApiGetOrder
     */
    readonly parentAddress?: string

    /**
     * 
     * @type {number}
     * @memberof UserApiGetOrder
     */
    readonly orderId?: number

    /**
     * 
     * @type {Array<string>}
     * @memberof UserApiGetOrder
     */
    readonly orderHashes?: Array<string>

    /**
     * 
     * @type {Array<OrderType>}
     * @memberof UserApiGetOrder
     */
    readonly orderType?: Array<OrderType>

    /**
     * 
     * @type {Array<OrderStatus>}
     * @memberof UserApiGetOrder
     */
    readonly statuses?: Array<OrderStatus>

    /**
     * 
     * @type {number}
     * @memberof UserApiGetOrder
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiGetOrder
     */
    readonly pageNumber?: number
}

/**
 * Request parameters for getOrdersByOrderType operation in UserApi.
 * @export
 * @interface UserApiGetOrdersByOrderTypeRequest
 */
export interface UserApiGetOrdersByOrderTypeRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiGetOrdersByOrderType
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof UserApiGetOrdersByOrderType
     */
    readonly orderId?: number

    /**
     * 
     * @type {Array<string>}
     * @memberof UserApiGetOrdersByOrderType
     */
    readonly orderHashes?: Array<string>

    /**
     * 
     * @type {Array<OrderStatus>}
     * @memberof UserApiGetOrdersByOrderType
     */
    readonly limitStatuses?: Array<OrderStatus>

    /**
     * 
     * @type {Array<OrderStatus>}
     * @memberof UserApiGetOrdersByOrderType
     */
    readonly marketStatuses?: Array<OrderStatus>

    /**
     * 
     * @type {number}
     * @memberof UserApiGetOrdersByOrderType
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiGetOrdersByOrderType
     */
    readonly pageNumber?: number
}

/**
 * Request parameters for getUserFundingHistory operation in UserApi.
 * @export
 * @interface UserApiGetUserFundingHistoryRequest
 */
export interface UserApiGetUserFundingHistoryRequest {
    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserFundingHistory
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserFundingHistory
     */
    readonly cursor?: number

    /**
     * 
     * @type {string}
     * @memberof UserApiGetUserFundingHistory
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof UserApiGetUserFundingHistory
     */
    readonly parentAddress?: string
}

/**
 * Request parameters for getUserPosition operation in UserApi.
 * @export
 * @interface UserApiGetUserPositionRequest
 */
export interface UserApiGetUserPositionRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiGetUserPosition
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof UserApiGetUserPosition
     */
    readonly parentAddress?: string

    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserPosition
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserPosition
     */
    readonly pageNumber?: number
}

/**
 * Request parameters for getUserTrade operation in UserApi.
 * @export
 * @interface UserApiGetUserTradeRequest
 */
export interface UserApiGetUserTradeRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiGetUserTrade
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof UserApiGetUserTrade
     */
    readonly parentAddress?: string

    /**
     * 
     * @type {boolean}
     * @memberof UserApiGetUserTrade
     */
    readonly maker?: boolean

    /**
     * 
     * @type {OrderType}
     * @memberof UserApiGetUserTrade
     */
    readonly orderType?: OrderType

    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserTrade
     */
    readonly fromId?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserTrade
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserTrade
     */
    readonly endTime?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserTrade
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserTrade
     */
    readonly pageNumber?: number
}

/**
 * Request parameters for getUserTradeHistory operation in UserApi.
 * @export
 * @interface UserApiGetUserTradeHistoryRequest
 */
export interface UserApiGetUserTradeHistoryRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiGetUserTradeHistory
     */
    readonly symbol?: string

    /**
     * 
     * @type {boolean}
     * @memberof UserApiGetUserTradeHistory
     */
    readonly maker?: boolean

    /**
     * 
     * @type {OrderType}
     * @memberof UserApiGetUserTradeHistory
     */
    readonly orderType?: OrderType

    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserTradeHistory
     */
    readonly fromId?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserTradeHistory
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserTradeHistory
     */
    readonly endTime?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserTradeHistory
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserTradeHistory
     */
    readonly cursor?: number
}

/**
 * Request parameters for getUserTransactionHistory operation in UserApi.
 * @export
 * @interface UserApiGetUserTransactionHistoryRequest
 */
export interface UserApiGetUserTransactionHistoryRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiGetUserTransactionHistory
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserTransactionHistory
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserTransactionHistory
     */
    readonly pageNumber?: number
}

/**
 * Request parameters for getUserTransfer operation in UserApi.
 * @export
 * @interface UserApiGetUserTransferRequest
 */
export interface UserApiGetUserTransferRequest {
    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserTransfer
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiGetUserTransfer
     */
    readonly cursor?: number

    /**
     * 
     * @type {TransferActions}
     * @memberof UserApiGetUserTransfer
     */
    readonly action?: TransferActions
}

/**
 * Request parameters for verifyDeposit operation in UserApi.
 * @export
 * @interface UserApiVerifyDepositRequest
 */
export interface UserApiVerifyDepositRequest {
    /**
     * 
     * @type {number}
     * @memberof UserApiVerifyDeposit
     */
    readonly depositAmount: number
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {UserApiAdjustLeverageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public adjustLeverage(requestParameters: UserApiAdjustLeverageRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).adjustLeverage(requestParameters.adjustLeverageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiAuthRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public auth(requestParameters: UserApiAuthRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).auth(requestParameters.userAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiFaucetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public faucet(requestParameters: UserApiFaucetRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).faucet(requestParameters.faucetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public fundGas(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).fundGas(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getAccount(requestParameters: UserApiGetAccountRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getAccount(requestParameters.parentAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetAccountPermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getAccountPermissions(requestParameters: UserApiGetAccountPermissionsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getAccountPermissions(requestParameters.userAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetAccountValueOverTimeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getAccountValueOverTime(requestParameters: UserApiGetAccountValueOverTimeRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getAccountValueOverTime(requestParameters.startTime, requestParameters.interval, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetOpenOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getOpenOrder(requestParameters: UserApiGetOpenOrderRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getOpenOrder(requestParameters.symbol, requestParameters.parentAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getOrder(requestParameters: UserApiGetOrderRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getOrder(requestParameters.symbol, requestParameters.parentAddress, requestParameters.orderId, requestParameters.orderHashes, requestParameters.orderType, requestParameters.statuses, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetOrdersByOrderTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getOrdersByOrderType(requestParameters: UserApiGetOrdersByOrderTypeRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getOrdersByOrderType(requestParameters.symbol, requestParameters.orderId, requestParameters.orderHashes, requestParameters.limitStatuses, requestParameters.marketStatuses, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetUserFundingHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserFundingHistory(requestParameters: UserApiGetUserFundingHistoryRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserFundingHistory(requestParameters.pageSize, requestParameters.cursor, requestParameters.symbol, requestParameters.parentAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetUserPositionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserPosition(requestParameters: UserApiGetUserPositionRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserPosition(requestParameters.symbol, requestParameters.parentAddress, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetUserTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserTrade(requestParameters: UserApiGetUserTradeRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserTrade(requestParameters.symbol, requestParameters.parentAddress, requestParameters.maker, requestParameters.orderType, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetUserTradeHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserTradeHistory(requestParameters: UserApiGetUserTradeHistoryRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserTradeHistory(requestParameters.symbol, requestParameters.maker, requestParameters.orderType, requestParameters.fromId, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserTraderOverView(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserTraderOverView(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetUserTransactionHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserTransactionHistory(requestParameters: UserApiGetUserTransactionHistoryRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserTransactionHistory(requestParameters.symbol, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetUserTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserTransfer(requestParameters: UserApiGetUserTransferRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserTransfer(requestParameters.pageSize, requestParameters.cursor, requestParameters.action, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiVerifyDepositRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public verifyDeposit(requestParameters: UserApiVerifyDepositRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).verifyDeposit(requestParameters.depositAmount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V2MarketApi - axios parameter creator
 * @export
 */
export const V2MarketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} symbol 
         * @param {string} [traders] 
         * @param {number} [limit] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTrade: async (symbol: string, traders?: string, limit?: number, startTime?: number, endTime?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getRecentTrade', 'symbol', symbol)
            const localVarPath = `/v2/market/recent-trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (traders !== undefined) {
                localVarQueryParameter['traders'] = traders;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V2MarketApi - functional programming interface
 * @export
 */
export const V2MarketApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V2MarketApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} symbol 
         * @param {string} [traders] 
         * @param {number} [limit] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentTrade(symbol: string, traders?: string, limit?: number, startTime?: number, endTime?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRecentTrade200Response1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentTrade(symbol, traders, limit, startTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V2MarketApi - factory interface
 * @export
 */
export const V2MarketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V2MarketApiFp(configuration)
    return {
        /**
         * 
         * @param {V2MarketApiGetRecentTradeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTrade(requestParameters: V2MarketApiGetRecentTradeRequest, options?: AxiosRequestConfig): AxiosPromise<GetRecentTrade200Response1> {
            return localVarFp.getRecentTrade(requestParameters.symbol, requestParameters.traders, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getRecentTrade operation in V2MarketApi.
 * @export
 * @interface V2MarketApiGetRecentTradeRequest
 */
export interface V2MarketApiGetRecentTradeRequest {
    /**
     * 
     * @type {string}
     * @memberof V2MarketApiGetRecentTrade
     */
    readonly symbol: string

    /**
     * 
     * @type {string}
     * @memberof V2MarketApiGetRecentTrade
     */
    readonly traders?: string

    /**
     * 
     * @type {number}
     * @memberof V2MarketApiGetRecentTrade
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof V2MarketApiGetRecentTrade
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof V2MarketApiGetRecentTrade
     */
    readonly endTime?: number
}

/**
 * V2MarketApi - object-oriented interface
 * @export
 * @class V2MarketApi
 * @extends {BaseAPI}
 */
export class V2MarketApi extends BaseAPI {
    /**
     * 
     * @param {V2MarketApiGetRecentTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2MarketApi
     */
    public getRecentTrade(requestParameters: V2MarketApiGetRecentTradeRequest, options?: AxiosRequestConfig) {
        return V2MarketApiFp(this.configuration).getRecentTrade(requestParameters.symbol, requestParameters.traders, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V2UserApi - axios parameter creator
 * @export
 */
export const V2UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [symbol] 
         * @param {string} [parentAddress] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder: async (symbol?: string, parentAddress?: string, startTime?: number, endTime?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/user/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (parentAddress !== undefined) {
                localVarQueryParameter['parentAddress'] = parentAddress;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {string} [symbol] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {string} [parentAddress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFundingHistory: async (limit?: number, symbol?: string, startTime?: number, endTime?: number, parentAddress?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/user/funding-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (parentAddress !== undefined) {
                localVarQueryParameter['parentAddress'] = parentAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {string} [parentAddress] 
         * @param {boolean} [maker] 
         * @param {OrderType} [orderType] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTrade: async (symbol?: string, parentAddress?: string, maker?: boolean, orderType?: OrderType, startTime?: number, endTime?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/user/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (parentAddress !== undefined) {
                localVarQueryParameter['parentAddress'] = parentAddress;
            }

            if (maker !== undefined) {
                localVarQueryParameter['maker'] = maker;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {number} [limit] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransactionHistory: async (symbol?: string, limit?: number, startTime?: number, endTime?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/user/transaction-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {TransferActions} [action] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransfer: async (limit?: number, action?: TransferActions, startTime?: number, endTime?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/user/transfer-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V2UserApi - functional programming interface
 * @export
 */
export const V2UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V2UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [symbol] 
         * @param {string} [parentAddress] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrder(symbol?: string, parentAddress?: string, startTime?: number, endTime?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrder200Response1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrder(symbol, parentAddress, startTime, endTime, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {string} [symbol] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {string} [parentAddress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFundingHistory(limit?: number, symbol?: string, startTime?: number, endTime?: number, parentAddress?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserFundingHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFundingHistory(limit, symbol, startTime, endTime, parentAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {string} [parentAddress] 
         * @param {boolean} [maker] 
         * @param {OrderType} [orderType] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTrade(symbol?: string, parentAddress?: string, maker?: boolean, orderType?: OrderType, startTime?: number, endTime?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTradeHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTrade(symbol, parentAddress, maker, orderType, startTime, endTime, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {number} [limit] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTransactionHistory(symbol?: string, limit?: number, startTime?: number, endTime?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTransactionHistory200Response1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTransactionHistory(symbol, limit, startTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {TransferActions} [action] 
         * @param {number} [startTime] 
         * @param {number} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTransfer(limit?: number, action?: TransferActions, startTime?: number, endTime?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTransfer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTransfer(limit, action, startTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V2UserApi - factory interface
 * @export
 */
export const V2UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V2UserApiFp(configuration)
    return {
        /**
         * 
         * @param {V2UserApiGetOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(requestParameters: V2UserApiGetOrderRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetOrder200Response1> {
            return localVarFp.getOrder(requestParameters.symbol, requestParameters.parentAddress, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V2UserApiGetUserFundingHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFundingHistory(requestParameters: V2UserApiGetUserFundingHistoryRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetUserFundingHistory200Response> {
            return localVarFp.getUserFundingHistory(requestParameters.limit, requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.parentAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V2UserApiGetUserTradeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTrade(requestParameters: V2UserApiGetUserTradeRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetUserTradeHistory200Response> {
            return localVarFp.getUserTrade(requestParameters.symbol, requestParameters.parentAddress, requestParameters.maker, requestParameters.orderType, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V2UserApiGetUserTransactionHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransactionHistory(requestParameters: V2UserApiGetUserTransactionHistoryRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetUserTransactionHistory200Response1> {
            return localVarFp.getUserTransactionHistory(requestParameters.symbol, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V2UserApiGetUserTransferRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransfer(requestParameters: V2UserApiGetUserTransferRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetUserTransfer200Response> {
            return localVarFp.getUserTransfer(requestParameters.limit, requestParameters.action, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getOrder operation in V2UserApi.
 * @export
 * @interface V2UserApiGetOrderRequest
 */
export interface V2UserApiGetOrderRequest {
    /**
     * 
     * @type {string}
     * @memberof V2UserApiGetOrder
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof V2UserApiGetOrder
     */
    readonly parentAddress?: string

    /**
     * 
     * @type {number}
     * @memberof V2UserApiGetOrder
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof V2UserApiGetOrder
     */
    readonly endTime?: number

    /**
     * 
     * @type {number}
     * @memberof V2UserApiGetOrder
     */
    readonly limit?: number
}

/**
 * Request parameters for getUserFundingHistory operation in V2UserApi.
 * @export
 * @interface V2UserApiGetUserFundingHistoryRequest
 */
export interface V2UserApiGetUserFundingHistoryRequest {
    /**
     * 
     * @type {number}
     * @memberof V2UserApiGetUserFundingHistory
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof V2UserApiGetUserFundingHistory
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof V2UserApiGetUserFundingHistory
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof V2UserApiGetUserFundingHistory
     */
    readonly endTime?: number

    /**
     * 
     * @type {string}
     * @memberof V2UserApiGetUserFundingHistory
     */
    readonly parentAddress?: string
}

/**
 * Request parameters for getUserTrade operation in V2UserApi.
 * @export
 * @interface V2UserApiGetUserTradeRequest
 */
export interface V2UserApiGetUserTradeRequest {
    /**
     * 
     * @type {string}
     * @memberof V2UserApiGetUserTrade
     */
    readonly symbol?: string

    /**
     * 
     * @type {string}
     * @memberof V2UserApiGetUserTrade
     */
    readonly parentAddress?: string

    /**
     * 
     * @type {boolean}
     * @memberof V2UserApiGetUserTrade
     */
    readonly maker?: boolean

    /**
     * 
     * @type {OrderType}
     * @memberof V2UserApiGetUserTrade
     */
    readonly orderType?: OrderType

    /**
     * 
     * @type {number}
     * @memberof V2UserApiGetUserTrade
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof V2UserApiGetUserTrade
     */
    readonly endTime?: number

    /**
     * 
     * @type {number}
     * @memberof V2UserApiGetUserTrade
     */
    readonly limit?: number
}

/**
 * Request parameters for getUserTransactionHistory operation in V2UserApi.
 * @export
 * @interface V2UserApiGetUserTransactionHistoryRequest
 */
export interface V2UserApiGetUserTransactionHistoryRequest {
    /**
     * 
     * @type {string}
     * @memberof V2UserApiGetUserTransactionHistory
     */
    readonly symbol?: string

    /**
     * 
     * @type {number}
     * @memberof V2UserApiGetUserTransactionHistory
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof V2UserApiGetUserTransactionHistory
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof V2UserApiGetUserTransactionHistory
     */
    readonly endTime?: number
}

/**
 * Request parameters for getUserTransfer operation in V2UserApi.
 * @export
 * @interface V2UserApiGetUserTransferRequest
 */
export interface V2UserApiGetUserTransferRequest {
    /**
     * 
     * @type {number}
     * @memberof V2UserApiGetUserTransfer
     */
    readonly limit?: number

    /**
     * 
     * @type {TransferActions}
     * @memberof V2UserApiGetUserTransfer
     */
    readonly action?: TransferActions

    /**
     * 
     * @type {number}
     * @memberof V2UserApiGetUserTransfer
     */
    readonly startTime?: number

    /**
     * 
     * @type {number}
     * @memberof V2UserApiGetUserTransfer
     */
    readonly endTime?: number
}

/**
 * V2UserApi - object-oriented interface
 * @export
 * @class V2UserApi
 * @extends {BaseAPI}
 */
export class V2UserApi extends BaseAPI {
    /**
     * 
     * @param {V2UserApiGetOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2UserApi
     */
    public getOrder(requestParameters: V2UserApiGetOrderRequest = {}, options?: AxiosRequestConfig) {
        return V2UserApiFp(this.configuration).getOrder(requestParameters.symbol, requestParameters.parentAddress, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V2UserApiGetUserFundingHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2UserApi
     */
    public getUserFundingHistory(requestParameters: V2UserApiGetUserFundingHistoryRequest = {}, options?: AxiosRequestConfig) {
        return V2UserApiFp(this.configuration).getUserFundingHistory(requestParameters.limit, requestParameters.symbol, requestParameters.startTime, requestParameters.endTime, requestParameters.parentAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V2UserApiGetUserTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2UserApi
     */
    public getUserTrade(requestParameters: V2UserApiGetUserTradeRequest = {}, options?: AxiosRequestConfig) {
        return V2UserApiFp(this.configuration).getUserTrade(requestParameters.symbol, requestParameters.parentAddress, requestParameters.maker, requestParameters.orderType, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V2UserApiGetUserTransactionHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2UserApi
     */
    public getUserTransactionHistory(requestParameters: V2UserApiGetUserTransactionHistoryRequest = {}, options?: AxiosRequestConfig) {
        return V2UserApiFp(this.configuration).getUserTransactionHistory(requestParameters.symbol, requestParameters.limit, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V2UserApiGetUserTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2UserApi
     */
    public getUserTransfer(requestParameters: V2UserApiGetUserTransferRequest = {}, options?: AxiosRequestConfig) {
        return V2UserApiFp(this.configuration).getUserTransfer(requestParameters.limit, requestParameters.action, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }
}


